c-----------------------------------------------------------------------
c--- Molden2AIM: a utility to convert the format from MOLDEN to AIM-WFN.
c--- Written in FORTRAN 77 and a bit of FORTRAN 90, and tested on
c--- Windows, Linux, and MacOSX.
c---
c--- Updated:
c--- Ver.1.0.0, 11/23/2009, The first public version. Supports MOLPRO.
c--- Ver.1.1.0, 11/25/2009, Renormalization of b.s. (subroutine renorm).
c--- Ver.1.2.0, 12/02/2009, Supports spherical Basis functions.
c--- Ver.1.3.0, 12/10/2009, Supports ORCA ([Program] Orca).
c--- Ver.1.4.0, 06/08/2010, Supports CFOUR ([Program] Cfour; spdf only).
c--- Ver.1.5.0, 06/09/2010, Supports TURBOMOLE ([Program] Turbomole).
c--- Ver.2.0.0, 12/20/2010, Checks the AIM-WFN file.
c--- Ver.2.1.0, 12/01/2013, Supports Dalton2013/TeraChem; PP is allowed;
c---                        generate a standard Molden file.
c--- Ver.2.1.1, 12/03/2013, Supports ACES-II 2.9; bug fix.
c--- Ver.2.2.0, 12/23/2013, Supports MOLCAS with Cartesian functions and
c---                        CFour with g-functions.
c--- Ver.3.0.0, 05/20/2014, Generates NBO's *.47 file; Reads .ini file;
c---                        util/ReOrdAtm.f90 for Molpro's MOLDEN
c--- Ver.3.0.1, 07/04/2014, bug fix for NBO6.
c--- Ver.3.0.2, 07/22/2014, Supports NWChem.
c--- Ver.3.0.3, 09/10/2014, Supports BDF and PSI4 (sph. functions only).
c--- Ver.3.0.4, 10/22/2014, Supports CADPAC.
c--- Ver.3.0.5, 11/21/2014, Supports MRCC (Cart. & spherical functions).
c--- Ver.3.0.6, 02/19/2015, ReOrdAtm.f90 has been updated for CFour.
c--- Ver.3.1.0, 02/25/2015, Check NBO's .47 file.
c---
c--- E-mail: qcband@gmail.com
c---
c--- Some changes were made to adapts this program to the LOWDIN software. 
c--- These changes are commented with the string "Lowdin". For further information :jacharrym@unal.edu.co
c---
c-----------------------------------------------------------------------

      subroutine Molden2AIM (inputFileName, totalEnergy, virial)
!!Lowdin	     add the inputFileName, totalEnergy and virial from lowdin		
!!Lowdin    change from  "program Molden2AIM" to subroutine
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

c---  MOLDEN files generated by the following programs require special
c     modifications
      parameter(nprog=8)
      character*20 pname(nprog)
c                    1       2           3        4       5        6
      data pname/'ORCA','CFOUR','TURBOMOLE','JAGUAR','ACES2','MOLCAS',
c          7      8
     & 'PSI4','MRCC'/

c---  Cartesian NC-/C-GTO; Spherical NC-/C-GTO
      dimension ncar(2),nsph(2)

      dimension ICntrl(7)
      logical doit

      character*57 fwfn,fnbo
      character*10 dt
      character*5 ver
      character*1 yn,L2U

c-----------------------------------------------------------------------
c---  input variables
!!Lowdin	define this variables
c-----------------------------------------------------------------------
      character*50 inputFileName
      real*8 totalEnergy,virial

c-----------------------------------------------------------------------
c---  head
c-----------------------------------------------------------------------
      ver="3.1.0"
      dt="02/25/2015"
      call headprt(ver,dt)

c-----------------------------------------------------------------------
c---  Initialization
c-----------------------------------------------------------------------
      ICntrl(1)=1         ! Generating a standard Molden file in Cartesian functions
      ICntrl(2)=1         ! Generating a WFN file
      ICntrl(3)=-1        ! Generating a WFX file (not implemented)
      ICntrl(4)=0         ! Generating a NBO .47 file
      ICntrl(5)=0         ! Checking normalization for WFN
      ICntrl(6)=-1        ! Checking normalization for WFX
      ICntrl(7)=0         ! Checking normalization for NBO's .47
                          ! >0:  always performs the operation without asking the user
                          ! =0:  asks the user whether to perform the operation
                          ! <0:  always neglect the operation without asking the user

      IAllMO=0            ! WFN and WFX
                          ! =0: print only the orbitals with occ. number > 5.0d-8
                          ! <0: print only the orbitals with occ. number > 0.1 (debug)
                          ! >0: print all the orbitals

      ICln=1              ! delete temporary files (1) or not (0)

      iprog=0             ! 1: ORCA, 2: CFOUR, 3: TURBOMOLE, 4: JAGUAR (not supported)
                          ! 5: ACES2, 6: MOLCAS
                          ! 0: other programs, or read [Program] xxx from MOLDEN.
                          ! If one of the above program is always used, you can provide
                          ! iprog here without defining [Program] xxx in MOLDEN any more.

c-----------------------------------------------------------------------
c---  Port numbers
c-----------------------------------------------------------------------
c     Do not modify the following port numbers.
c
c     Port numbers 4x: important input and output files
c     Port numbers 5x: temporary files
c     Port numbers 55, 56, and 57 will be defined later.
c
      iini=40             ! INI file
      imod=44             ! original molden file
      inmd=45             ! new molden file in Cartesian functions
      iwfn=46             ! wfn file
      iwfx=47             ! wfx file
      inbo=48             ! NBO 47 file

      iatm=50             ! coordinates
      igto=51             ! basis functions
      imol=52             ! MO data of Cartesian functions
      ispn=53             ! spins
      imo0=54             ! raw MO data; the missing zeros will be filled in
c     55, 56, 57: reserved


c     The following integers will be determined later. Do not modify them here.
c
      ifc4=1              ! a scaling factor for occ. numbers: x 1 (1) or x 2 (2)
      iecp=0              ! PP (ECP, MCP, or maybe Semi-empirical) is used (1) or not (0)
      lsph=0              ! MOs are in Cartesian (0) or spherical (1) basis functions

c     read user's parameters from m2a.ini
      call uinit(iini,nprog,ICntrl,ICln,IAllMO,iprog,nosupp)

c-----------------------------------------------------------------------
c---  program list which can save MOLDEN file
c-----------------------------------------------------------------------
      if(nosupp .eq. 0) call SuppInf

c-----------------------------------------------------------------------
c---  define file names
c-----------------------------------------------------------------------
      call filename(inputFileName,imod,fwfn,fnbo)
!!Lowdin add the inputFileName variable
      open(iatm,file='atm123456789.tmp')
      open(igto,file='gto123456789.tmp')
      open(imol,file='mol123456789.tmp')
      open(ispn,file='spn123456789.tmp')
      open(imo0,file='mo0123456789.tmp')

c-----------------------------------------------------------------------
c---  search [Program] and get the name of the program.
c---  [Program] is a special keyword for Molden2AIM.
c---  iprog = 0 (default), 1 (orca), 2 (cfour), 3 (turbomole), ...
c-----------------------------------------------------------------------
      call getprog(imod,nprog,pname,iprog)

c-----------------------------------------------------------------------
c---  backup molden file and delete some redundant (e.g. Pople GTO by
c---  ACES2) or not useful data (e.g. unoccupied orb.s)
c-----------------------------------------------------------------------
      call backupatm(ifind)
      if(ifind.eq.0)goto 9910           ! STOP: [ATOMS] was not found
      call natom(nat,nchar,iunit,ierr)  ! iunit = 0: Ang. 1: Bohr 2: Error
      if(ierr.ne.0)goto 9910            ! STOP: deMon2k's geometry optimization, or wrong ordering
      call backupgto(imod,nat,iprog,ifind)
      if(ifind.eq.0)goto 9910           ! STOP: [GTO] was not found, or wrong ordering
      call npgau(Ierr,ncar,nsph,MaxL)   ! # of uc. and c. GTO
      if(Ierr.eq.1)then
c---  For CFour, there may be basis functions higher than g
        write(*,*)"Error! Only S,P,D,F,G functions are supported!"
        write(*,*)"Please check your MOLDEN file."
        goto 9910
      else if(Ierr.eq.2)then
c---  ncar(1) > maxpg or ncar(2) > maxpgc
        goto 9910
      end if
c---  check: Car. vs Sph.
c      call checkcar(ncarmo,ifind)
      call checkcar2(ncarmo,ishrt,ifind)
      if(ifind.eq.0)goto 9910           ! STOP: [MO] was not found
      if(iprog .eq. 4)then
        ncarmo=ncar(2)
        ishrt=1
        lsph=0
        write(*,"(
     *    ' >>> Cartesian basis functions are used by Jaguar.',/)")
      else
        if(ncarmo.eq.ncar(2))then
          write(*,"(' >>> Cartesian basis functions are used.',/)")
          lsph=0
        else if(ncarmo.lt.ncar(2) .and. ncarmo.eq.nsph(2))then
          write(*,"(' >>> Spherical basis functions are used.',/)")
          lsph=1
c         molcas with spherical functions: do nothing
          if(iprog .eq. 6) iprog=-6
c         mrcc with spherical functions: do nothing
          if(iprog .eq. 8) iprog=-8
        else if(ncarmo.lt.ncar(2) .and. ncarmo.gt.nsph(2))then
          write(*,"(
     *    ' Wrong! NCARMO=',i5,', NCGTO=',i5,/,
     *    ' Sperical and Cartesian functions are mixed together.',/,
     *    ' This is not supported.')")
     *    ncarmo,ncar(2)
          goto 9910
        else
          write(*,"(' Wrong! NCARMO=',i5,', NCGTO=',i5,/)")
     *    ncarmo,ncar(2)
          goto 9910
        end if
      end if
c---  compute scaling factors of MO
      call moscale(iprog,ncar(2))

c---  backup MO
      call fill0s(imo0,ncarmo,ishrt)
      if(IAllMO .eq. 0)then
        tolocc=5.0d-8
      else if(IAllMO .gt. 0)then
        tolocc=-1.0d2
      else
        tolocc=1.0d-1 - 5.0d-8
      end if
      if(lsph.eq.0)then
        call backupmolc(imol,ispn,imo0,nmo,nmotot,sumocc,ifspin,ifbeta,
     &   ncar(2),tolocc,ierr)
      else
        call backupmols(imol,ispn,imo0,nmo,nmotot,sumocc,ifspin,ifbeta,
     &   iprog,tolocc,ierr)
      end if
      if(ierr.ne.0)then
        write(*,"(/,' Wrong! Star (*) is found in MO coefficients.',/,
     *' If the occupation is weak, please delete this MO and run again,'
     *,/,' otherwise you have to calculate the MO coefficient.')")
        goto 9910
      end if

      write(*,"(' >>> SUMMARY',//,
     & 5x,'Number of atoms: ',25x,i8,/,
     & 5x,'Maximum angular momentum: ',16x,i8,/,
     & 5x,'Number of primitive Cartesian functions: ',1x,i8,/,
     & 5x,'Number of contracted Cartesian functions: ',i8,/,
     & 5x,'Number of primitive spherical functions: ',1x,i8,/,
     & 5x,'Number of contracted spherical functions: ',i8,/,
     & 5x,'Number of orbitals to be printed: ',8x,i8)") nat,MaxL,
     & ncar(1),ncar(2),nsph(1),nsph(2),nmo

c-----------------------------------------------------------------------
c---  check
c-----------------------------------------------------------------------
      if(iprog.ne.0)then
        call chkbstyp(lsph,iprog,MaxL,ierr)
        if(ierr.ne.0) goto 9910
      end if
      if(nmo.lt.1)then
        write(*,*)"Error! No occupied MOs are found!"
        write(*,*)
c       There is a bug in Dalton2013, which may have been solve now.
        if(iprog.eq.0) write(*,*)
     &    "If you are using Dalton, try the latest version."
c       In old version of MRCC, occ=0 if occupations are specified
        if(abs(iprog).eq.8) write(*,*)"Try the latest version of MRCC."
        goto 9910
      end if
      if(ncar(1).lt.1)then
        write(*,*)"Error! No Primitive Basis Functions are found!"
        write(*,*)
        write(*,*)"Please check your MOLDEN file."
        goto 9910
      end if
      if(nat.lt.1)then
        write(*,*)"Error! No atoms are found!"
        write(*,*)
        write(*,*)"Please check your MOLDEN file."
        goto 9910
      end if
      if(iunit.ne.1.and.iunit.ne.0)then
        write(*,*)"Error! The unit of the coordinates is not defined!"
        write(*,*)
        write(*,*)"Please check your MOLDEN file."
        goto 9910
      end if
      if(abs(dble(nchar)-sumocc).gt.0.001d0)then
!!Lowdin	For multispecies calculation the charge is different, so we don't need to check the charge
!!        call chkcharge(nchar,sumocc,iprog,ifc4,iecp,ierr)
        if(ierr.ne.0)goto 9910
      end if
cccccc this bug has been fixed by a modified version of libr/reorderdf.f
c      if(MaxL.ge.4 .and. iprog.eq.2)then
c        write(*,*)">>> Error!"
c        write(*,*)
c     *  "Molden2AIM cannot read G-functions for CFour!"
c        goto 9910
c      end if
      write(*,8000)

c-----------------------------------------------------------------------
c---  write a standard Molden file in Cartesian basis functions
c-----------------------------------------------------------------------
      if(ICntrl(1) .gt. 0)then
        doit = .true.
      else if(ICntrl(1) .eq. 0)then
        write(*,"(////,
     *    ' Do you want to generate a new Molden file? ([Yes] / No)',/,
     *    ' > ',$)")
        read(*,"(a1)")yn
        yn=L2U(yn)
        if(yn.eq.'N')then
          doit = .false.
        else
          doit = .true.
        end if
      else
        doit = .false.
      end if

      if(doit) then
        call genmdn(fwfn,inmd,iatm,igto,imol,imo0,ver,dt,nat,nmotot,
     *    ncarmo,ncar(2),ifc4)
        close(inmd)
        write(*,8000)
      end if

c-----------------------------------------------------------------------
c---  write *.wfn
c-----------------------------------------------------------------------
      if(ICntrl(2) .gt. 0)then
        doit = .true.
      else if(ICntrl(2) .eq. 0)then
        write(*,"(////,
     *    ' Do you want to generate a *.WFN file? ([Yes] / No)',/,
     *    ' > ',$)")
        read(*,"(a1)")yn
        yn=L2U(yn)
        if(yn.eq.'N')then
          doit = .false.
        else
          doit = .true.
        end if
      else
        doit = .false.
      end if

      if(doit) then
        call writitle(iwfn,fwfn,ver,dt)

        write(iwfn,"('GAUSSIAN',8x,i7,' MOL ORBITALS',i7,' PRIMITIVES',
     *    i9,' NUCLEI')")nmo, ncar(1), nat

        call writeatm(iwfn,iatm,nat)
        call writecnt(iwfn,igto,imol,ncar(1))
        call writemol(iwfn,imol,nmotot,ncar(1),ncar(2),tolocc,ifc4)    ! ifc4=1 or 2 (CFour,Q-chem)
        write(iwfn,"('END DATA')")
!!Lowdin add the total energy and virial from HF calcuation with lowdin
        write(iwfn,"(' THE  HF ENERGY =',f20.12,' THE VIRIAL(-V/T)=',
     *    f13.8)")totalEnergy,virial

c       Spin of MO. These data can be used by MultiWFN.
c       if ifspin=0, "Spin" cannot be found in Molden
        if(ifspin.eq.1) call writespn(iwfn,ispn,ifbeta,nmo)

c       final step
        call finalwfn(fwfn,iecp,MaxL)

c---    Check the AIM-WFN file
        if(ICntrl(5) .gt. 0)then
          doit = .true.
        else if(ICntrl(5) .eq. 0)then
          write(*,"(/,
     *    ' Do you want to check the *.WFN file? ([Yes] / No)')")
c         WFN with ECP is supported only by MultiWFN at present
          if(iecp .eq. 0) write(*,"(
     *    ' (Omit it if you are using AIMALL because AIMALL will',
     *    ' do it much faster.)')")
          write(*,"(' > ',$)")
          read(*,"(a1)")yn
          yn=L2U(yn)
          if(yn.eq.'N')then
            doit = .false.
          else
            doit = .true.
          end if
        else
          doit = .false.
        end if

        if(doit) then
          call CheckWFN(nat,ncar(1),MaxL,info)
          if(info.ne.0) goto 9910
        end if
        close(iwfn)
        write(*,8000)
      end if

c-----------------------------------------------------------------------
c---  write *.wfx
c-----------------------------------------------------------------------
      if(ICntrl(3) .gt. 0)then
        doit = .true.
      else if(ICntrl(3) .eq. 0)then
        write(*,"(////,
     *    ' Do you want to generate a *.WFX file? ([Yes] / No)',/,
     *    ' > ',$)")
        read(*,"(a1)")yn
        yn=L2U(yn)
        if(yn.eq.'N')then
          doit = .false.
        else
          doit = .true.
        end if
      else
        doit = .false.
      end if

      if(doit) then
        write(*,"(/,' Not implemented. Do nothing.')")

c---    Check the AIM-WFX file
c        if(ICntrl(6) .gt. 0)then
c          doit = .true.
c        else if(ICntrl(6) .eq. 0)then
c          write(*,"(////,
c     *    ' Do you want to check the *.WFX file? ([Yes] / No)',/,
c     *    ' (Omit it if you are using AIMALL because AIMALL will',
c     *    ' do it much faster.)',/,
c     *    ' > ',$)")
c          read(*,"(a1)")yn
c          yn=L2U(yn)
c          if(yn.eq.'N')then
c            doit = .false.
c          else
c            doit = .true.
c          end if
c        else
c          doit = .false.
c        end if
c
c        if(doit) then
c          call CheckWFX(info)
c          if(info.ne.0) goto 9910
c        end if
c        close(iwfx)

        write(*,8000)
      end if

c-----------------------------------------------------------------------
c---  write NBO *.47
c-----------------------------------------------------------------------
      if(ICntrl(4) .gt. 0)then
        doit = .true.
      else if(ICntrl(4) .eq. 0)then
        write(*,"(////,
     *    ' Do you want to generate NBO *.47 file? ([Yes] / No)',/,
     *    ' > ',$)")
        read(*,"(a1)")yn
        yn=L2U(yn)
        if(yn.eq.'N')then
          doit = .false.
        else
          doit = .true.
        end if
      else
        doit = .false.
      end if

      if(doit) then
        OPEN(inbo,FILE=fnbo)
        call cbsinf(igto,nat,nshell,nexp)
        call gennbo(inbo,iatm,igto,imol,ver,dt,nat,nshell,nexp,ncar(2),
     &   nmotot,MaxL,ifc4,info)
        if(info.ne.0) goto 9910

c       final step
        call finalnbo(fnbo,MaxL,iecp)

c---    Check the NBO .47 file
        if(ICntrl(7) .gt. 0)then
          doit = .true.
        else if(ICntrl(7) .eq. 0)then
          write(*,"(/,
     *    ' Do you want to check the *.47 file? ([Yes] / No)')")
          write(*,"(' > ',$)")
          read(*,"(a1)")yn
          yn=L2U(yn)
          if(yn.eq.'N')then
            doit = .false.
          else
            doit = .true.
          end if
        else
          doit = .false.
        end if

        if(doit) then
          call CheckNBO(inbo,nat,ncar(2),sumocc*dble(ifc4),info)
          if(info.ne.0) goto 9910
        end if
        close(inbo)
        write(*,8000)
      end if

c-----------------------------------------------------------------------
9910  continue
      close(imod)
      if(ICln .eq. 0)then
        close(iatm)
        close(igto)
        close(imol)
        close(ispn)
        close(imo0)
      else
        close(iatm,status='delete')
        close(igto,status='delete')
        close(imol,status='delete')
        close(ispn,status='delete')
        close(imo0,status='delete')
      end if

      call estop

8000  format(1x,77('='))
      end

c-----------------------------------------------------------------------
c-------EEEEEEEEEEEEE-----NNN-------NNN-----DDDDDDDDDDD-----------------
c-------EEEEEEEEEEEEE-----NNNN------NNN-----DDDDDDDDDDDD----------------
c-------EEE---------------NNNNN-----NNN-----DDD-------DDD---------------
c-------EEE---------------NNN-NN----NNN-----DDD-------DDD---------------
c-------EEEEEEEEEEEEE-----NNN--NN---NNN-----DDD-------DDD---------------
c-------EEEEEEEEEEEEE-----NNN---NN--NNN-----DDD-------DDD---------------
c-------EEE---------------NNN----NN-NNN-----DDD-------DDD---------------
c-------EEE---------------NNN-----NNNNN-----DDD-------DDD---------------
c-------EEEEEEEEEEEEE-----NNN------NNNN-----DDDDDDDDDDDD----------------
c-------EEEEEEEEEEEEE-----NNN-------NNN-----DDDDDDDDDDD-----------------
c-----------------------------------------------------------------------

c-----------------------------------------------------------------------
c---  Read user's initialization parameters from m2a.ini
c-----------------------------------------------------------------------
      Subroutine uinit(iini,nprog,ICntrl,ICln,IAllMO,iprog,nosupp)
      Implicit Real*8(A-H,O-Z)
      Dimension ICntrl(7)
      character*100 ctmp
      parameter(nkey=11)
      character*9 keyword(nkey)
      data keyword/"MOLDEN=","WFN=","WFX=","NBO=","WFNCHECK=",
     & "WFXCHECK=","NBOCHECK=","PROGRAM=","CLEAR=","IALLMO=",
     & "NOSUPP="/

      open(iini,file='m2a.ini',status='old',err=9000)
      rewind(iini)

      do while(.true.)
        read(iini,"(a100)",end=9000)ctmp

        if(ctmp(1:1) .eq. "$" .or. ctmp(1:1) .eq. "%" .or.
     &     ctmp(1:1) .eq. "!" .or. len_trim(ctmp) .eq. 0) cycle

        call charl2u(ctmp,100)
        ikey=0
        do i=1,nkey
          if(index(ctmp,trim(keyword(i))) .ne. 0) then
            ikey=i
            istart=index(ctmp,"=")+1
            read(ctmp(istart:100),*)keyvalue
            exit
          end if
        end do

        if(ikey .eq. 0) cycle

        select case(ikey)
          case(1:7)
            if(keyvalue .gt. 0) then
              keyvalue=1
            else if(keyvalue .lt. 0) then
              keyvalue=-1
            end if
            ICntrl(ikey)=keyvalue
          case(8)
            if(keyvalue .lt. 0 .or. keyvalue .gt. nprog) keyvalue=0
            iprog=keyvalue
          case(9)
            if(keyvalue .ne. 0) keyvalue=1
            ICln=keyvalue
          case(10)
            if(keyvalue .gt. 0)then
              keyvalue=1
            else if(keyvalue .lt. 0)then
              keyvalue=-1
            end if
            IAllMO=keyvalue
          case(11)
            nosupp = 0
            if(keyvalue .ne. 0) nosupp = 1
        end select
      end do
      close(iini)

9000  return
      End

c-----------------------------------------------------------------------
c---  generate NBO's *.47 data file (always in Cartesian functions).
c
c     Paremeters
c     inbo,iatm,igto
c                 : ports
c     ver,dt      : version number and date
c     natm        : # atoms
c     nshell      : # contracted shells
c     nexp        : # primitive exponents
c     nbas        : # contracted Cartesian basis functions
c     MaxL        : max L (<=4 at present)
c
c NOTE:
c
c 1) It requires overlap and density in contracted Cartesian functions.
c
c 2) Fock matrix is not available, so the 2'nd order of perturbation
c    cannot be calculated.
c
c 3) T and V: optional and not calculated here. They are not defined
c    in the case of all-electron scalar relativistic calculation.
c
c 4) $LCAOMO requires both occupied and unoccupied MOs, and #MO = #BAS.
c    However this may be not true since Cartesian basis functions are
c    always used here. Because of this reason, $LCAOMO is ignored at
c    present.
c
c 5) If ECP is used, you have to correct iz(2) in $COORD by hand.
c
c-----------------------------------------------------------------------
      subroutine gennbo(inbo,iatm,igto,imol,ver,dt,natm,nshell,nexp,
     & nbas,nmo,MaxL,ifc4,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(au2ang=0.529177249d0)
c     scalmo will be used
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
c
      character*4 cnatm
      character*5 cnbas, ver
      character*10 dt
      character*100 ctmp
      dimension xyz(3,natm),ncomp(nshell),nprim(nshell),nptr(nshell),
     & ncshl(nshell),expn(nexp),con(nexp),nc(nbas),label(nbas)
      dimension scr1(nbas*(nbas+1)/2),scr2(max(15*15,nbas))

      lsph=0    ! always in Cartesian functions

      rewind(inbo)

      write(cnatm,"(i4)")natm
      cnatm=ADJUSTL(cnatm)
      write(cnbas,"(i5)")nbas
      cnbas=ADJUSTL(cnbas)

c     gennbo: $GENNBO
      write(inbo,"(' $GENNBO  NATOMS=',a4,' NBAS=',a5,
     *' UPPER  BODM  $END')")cnatm,cnbas

c     gennbo: $NBO
      write(inbo,"(' $NBO BNDIDX NLMO $END')")

c     gennbo: $COORD
      write(inbo,"(' $COORD')")
c---  if fdate doesn't work, just use this line
c      write(iwfn,"(' Molden2AIM, Version ',a5,' (',a10,')')")ver,dt
      call fdate(ctmp)
      call trulen(ctmp,L1,L2,length)
      write(inbo,"(' Molden2AIM, Version ',a5,' (',a10,')',11x,
     *'Time: ',a24)")ver,dt,ctmp(L1:L2)
c
      rewind(iatm)
      read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
      fc=1.d0
      if(iu .ne. 0)fc=au2ang
      do i=1,natm
        read(iatm,*)ctmp,ia,iz,xyz(1,i),xyz(2,i),xyz(3,i)
        call ascale(3,fc,xyz(1,i),xyz(1,i))
c       About NBO6:
c       1. It may lead to numerical errors of about 1.0d-6 in the overlap matrix,
c       which cannot pass the examination of NBO6. More digits should be printed.
c       2. au2ang: in NBO3, 0.529177249 is used instead of 0.529177. This may be
c       also true in NBO6.
cooo        write(inbo,"(1x,2i5,3f15.6)")iz,iz,xyz(1,i),xyz(2,i),xyz(3,i)
        write(inbo,"(1x,2i5,3f18.9)")iz,iz,xyz(1,i),xyz(2,i),xyz(3,i)
      end do
      write(inbo,"(' $END')")
c     xyz: Ang. --> Bohr
      call ascale(3*natm,(1.d0/au2ang),xyz,xyz)

c     read contracted basis functions from igto
      call RdConBF(igto,natm,nshell,nexp,nbas,lsph,ncomp,nprim,nptr,
     & ncshl,expn,con,nc,label)

c     gennbo: $BASIS
      call wrbas(inbo,nbas,nc,label)

c     gennbo: $CONTRACT
      call wrctr(inbo,nshell,nexp,MaxL,lsph,ncomp,nprim,nptr,expn,con,
     & scr1)

c     gennbo: $OVERLAP
      write(*,"(/,'  Calculating overlap matrix...')")
      call OvDriv2(inbo,nshell,nexp,nbas,MaxL,lsph,xyz,ncomp,nprim,
     & nptr,ncshl,expn,con,scr1,scr2,info)
        if(info.ne.0) return

c     gennbo: $DENSITY
      write(*,"('  Calculating density matrix...')")
      call DenDriv(inbo,imol,nbas,nmo,dble(ifc4),scalmo,scr1,scr2)

      return
      end

c-----------------------------------------------------------------------
c---  driver of density matrix calculation
c
c     nbas: # contracted Cartesian functions
c     nmo:  # MO
c     focc: a pre-factor of occupation number (1.0 or 2.0)
c     scalmo: scaling factors of MO coefficients
c-----------------------------------------------------------------------
      subroutine DenDriv(inbo,imol,nbas,nmo,focc,scalmo,Den,cmo)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(occtol=1.d-8)
      dimension scalmo(*),Den(*),cmo(*)

      NTTS=nbas*(nbas+1)/2
      call AClear(NTTS,Den)

      rewind(imol)
      do i=1,nmo
c       read occ. number & MO coefficients from imol (in Cartesian b.s.)
        read(imol,"(7x,f20.8)")occ
        read(imol,*)
        occ=focc*occ
        do ibs=1,nbas
          read(imol,*)idx,cmo(ibs)
          cmo(ibs)=cmo(ibs)*scalmo(ibs)
        end do
        if(abs(occ) .lt. occtol) cycle

c       density matrix
        j=0
        do ibs=1,nbas
          do jbs=1,ibs
            j=j+1
            Den(j)=Den(j)+occ*cmo(ibs)*cmo(jbs)
          end do
        end do
        
      end do

      call noiserm(Den,NTTS)
c      call PrtMtr(nbas,NTTS,1,Den)
      write(inbo,"(' $DENSITY')")
      write(inbo,"(2x,5e15.7e2)")(Den(i),i=1,NTTS)
      write(inbo,"(' $END')")

      return
      end

c-----------------------------------------------------------------------
c---  driver of overlap matrix (contracted and spherical)
c-----------------------------------------------------------------------
      subroutine OvDriv2(inbo,nshell,nexp,nbas,MaxL,lsph,xyz,ncomp,
     &  nprim,nptr,ncshl,expn,con,SMat,scr,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension xyz(3,*),ncomp(nshell),nprim(nshell),nptr(nshell),
     & ncshl(nshell),expn(nexp),con(nexp)
      dimension ra(3),rb(3),ncat(0:4)
      dimension SMat(*),scr(15*15)
      dimension sblk(15*15)   ! for Cart. <lq|lq> integrals, lq <= g
      data ncat/0,1,4,10,20/

      pi=acos(-1.d0)
      NTTS=nbas*(nbas+1)/2
      call AClear(NTTS,SMat)

      IBS=0
      do ishell = 1, nshell
        ra(1) = xyz(1,ncshl(ishell))
        ra(2) = xyz(2,ncshl(ishell))
        ra(3) = xyz(3,ncshl(ishell))
        nspa=ncomp(ishell)     ! nspa & nspb: #Cart./sph. b.s. (depending on lsph) in a shell
        ityp = LQuant(nspa)    ! ityp & jtyp: 0 (s), 1 (p), 2 (d), ...
        npta=(ityp+1)*(ityp+2)/2
        i1 = nptr(ishell)
        i2 = i1 + nprim(ishell) - 1
        JBS=0
        do jshell = 1, ishell
          rb(1) = xyz(1,ncshl(jshell))
          rb(2) = xyz(2,ncshl(jshell))
          rb(3) = xyz(3,ncshl(jshell))
          nspb=ncomp(jshell)
          jtyp = LQuant(nspb)
          nptb=(jtyp+1)*(jtyp+2)/2
          rab = dist(ra,rb)
          j1 = nptr(jshell)
          j2 = j1 + nprim(jshell) - 1
c-------- for contracted shells ishell and jshell
          do igto = i1,i2
            as = expn(igto)
            acn= con(igto)
            do jgto = j1,j2
              bs = expn(jgto)
              bcn= con(jgto)
c------------ for primitive Cartesian GTO_i and GTO_j: sblk(nptb,npta)
              call poverlap(sblk,
     &          as,npta,ncat(ityp),ra, bs,nptb,ncat(jtyp),rb,
     &          pi,MaxL,rab,info)
                if(info.ne.0) goto 9000
c------------ for primitive spherical GTO_i and GTO_j: sblk(nspb,nspa)
              if(lsph .ne. 0 .and. (ityp .gt. 1 .or. jtyp .gt. 1))
     &          call car2sph(sblk,scr,npta,nptb,nspa,nspb)
c------------ do contraction for sblk(nspb,nspa)
              call AScale(nspa*nspb,acn*bcn,sblk,sblk)
              call PackLT(SMat,IBS,JBS,sblk,nspa,nspb,ishell.eq.jshell)
            end do
          end do
c
          JBS=JBS+nspb
        end do
        IBS=IBS+nspa
      end do

      call noiserm(SMat,NTTS)
c      call PrtMtr(nbas,NTTS,1,SMat)
      write(inbo,"(' $OVERLAP')")
      write(inbo,"(2x,5e15.7e2)")(SMat(i),i=1,NTTS)
      write(inbo,"(' $END')")

9000  return
      end

cc-----------------------------------------------------------------------
cc---  Print a group of lower triangular matrices
cc-----------------------------------------------------------------------
c      Subroutine PrtMtr(N,NT,M,A)
c      Implicit Real*8(A-H,O-Z)
c      Dimension A(NT,M)
c
c      Do I = 1,M
c        write(99,"(/,' ** Mat-',i3)")I
c        K2 = 0
c        Do J = 1,N
c          K1 = K2 + 1
c          K2 = K1 + J - 1
c          write(99,"(i4,1000d15.7)")J,(A(K,I),K=K1,K2)
c        end do
c      end do
c
c      Return
c      End
c
c-----------------------------------------------------------------------
c---  Removal of numerical noise before printing array A.
c     Some compilers print stars (***) if ABS(A(i)) <= 1.0d-100.
c-----------------------------------------------------------------------
      subroutine noiserm(A,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(eps=1.0d-20,zero=0.0d0)
      dimension A(*)

      do i=1,N
      	if(abs(A(i)) .lt. eps) A(i)=zero
      end do

      return
      end

c-----------------------------------------------------------------------
c---  put overlap integrals of ci*cj*<IGTO|JGTO> into overlap matrix S.
c     IBS and JBS are row and column indices which have been finished
c     already.
c-----------------------------------------------------------------------
      subroutine PackLT(S,IBS,JBS,si,nspa,nspb,LT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension S(*),si(nspb,nspa)
      logical LT

      do i=1,nspa
        ii=IBS+i
        jj=JBS
        kk=IdxNTT(jj,ii)
        nspb2=nspb
        if(LT) nspb2=i
        do j=1,nspb2
          kk=kk+1
          S(kk)=S(kk)+si(j,i)
        end do
      end do

      return
      end

c-----------------------------------------------------------------------
c---  converts Cartesian matrix s to spherical matrix, and save to s:
c     amap^T * s(npta x nptb) * bmap --> s(nspa x nspb)
c-----------------------------------------------------------------------
      subroutine car2sph(s,tmp,npta,nptb,nspa,nspb)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension s(nptb,npta),tmp(*)
c     dmap, fmap, and gmap have been initialized in sph2car
      common/carsph/dmap(6,5),fmap(10,7),gmap(15,9)

C     First half of transformation:
      if(nptb .le. 3)then        ! S, P
        call acopy(nptb*npta,s,tmp)
      else if(nptb .eq. 6)then   ! Cart. D
        call MatMul(2,nspb,nptb,npta,dmap,s,tmp)
      else if(nptb .eq. 10)then  ! Cart. F
        call MatMul(2,nspb,nptb,npta,fmap,s,tmp)
      else if(nptb .eq. 15)then  ! Cart. G
        call MatMul(2,nspb,nptb,npta,gmap,s,tmp)
      end if

C     Second half of transformation:
      if(npta .le. 3)then        ! S, P
        call acopy(nspa*nspb,tmp,s)
      else if(npta .eq. 6)then   ! Cart. D
        call MatMul(1,nspb,npta,nspa,tmp,dmap,s)
      else if(npta .eq. 10)then  ! Cart. F
        call MatMul(1,nspb,npta,nspa,tmp,fmap,s)
      else if(npta .eq. 15)then  ! Cart. G
        call MatMul(1,nspb,npta,nspa,tmp,gmap,s)
      end if

      return
      end

c-----------------------------------------------------------------------
c     Mode = 1: C = A * B
c            2: C = A^T * B
c            3: C = A * B^T
c            4: C = A^T * B^T
c     where C(MxN), op(A)(MxL), and op(B)(LxN)
c-----------------------------------------------------------------------
      subroutine MatMul(Mode,M,L,N,A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(Zero=0.d0,One=1.d0)
      dimension A(*),B(*),C(*)

      LDC=M
      if(Mode .eq. 1)then
        LDA=M
        LDB=L
        call DGEMM('N','N',M,N,L,One,A,LDA,B,LDB,Zero,C,LDC)
      else if(Mode .eq. 2)then
        LDA=L
        LDB=L
        call DGEMM('T','N',M,N,L,One,A,LDA,B,LDB,Zero,C,LDC)
      else if(Mode .eq. 3)then
        LDA=M
        LDB=N
        call DGEMM('N','T',M,N,L,One,A,LDA,B,LDB,Zero,C,LDC)
      else if(Mode .eq. 4)then
        LDA=L
        LDB=N
        call DGEMM('T','T',M,N,L,One,A,LDA,B,LDB,Zero,C,LDC)
      end if

      return
      end

c-----------------------------------------------------------------------
c---  overlap integrals for primitive Cartesian GTO_i and GTO_j
c-----------------------------------------------------------------------
      subroutine poverlap(s6d, as,npta,ioffst,ra, bs,nptb,joffst,rb,
     &  pi,MaxL,rab,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension s6d(nptb,npta),ra(3),rb(3)

      do icat=1,npta
        ipat=icat+ioffst
c       normalization factor
        fna=fnorm_lmn(as,ipat)
        call pattml(ipat,l1,m1,n1,info)
          if(info.ne.0) goto 9000
        do jcat=1,nptb
          jpat=jcat+joffst
c         normalization factor
          fnb=fnorm_lmn(bs,jpat)
          call pattml(jpat,l2,m2,n2,info)
            if(info.ne.0) goto 9000
          call overlap2(s6d(jcat,icat),  
     &     l1,m1,n1,as,ra,fna,  l2,m2,n2,bs,rb,fnb,
     &     pi,MaxL,rab)
        end do
      end do

9000  return
      end

c-----------------------------------------------------------------------
c---  calculate an overlap matrix element
c                  <as(ra);l1,m1,n1 | bs(rb);l2,m2,n2>
c     another version
c-----------------------------------------------------------------------
      subroutine overlap2(s,  
     &  l1,m1,n1,as,ra,fna,  l2,m2,n2,bs,rb,fnb,
     &  pi,MaxL,rab)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension ra(3),rb(3),p(3),dgn(0:MaxL),pan(0:MaxL,3),pbn(0:MaxL,3)
      data one/1.d0/
      save one

c---  gamma = as + bs and (2*gamma)^-n
      g=as+bs
      dg=g+g
      dgn(0)=one
      do i=1,MaxL
        dgn(i)=dgn(i-1)/dg
      end do
      tmp1=sqrt(pi/g)

      s=fna*fnb*exp(-as*bs*rab*rab/g)*tmp1*tmp1*tmp1

c---  P point
      p(1)=(as*ra(1)+bs*rb(1))/g
      p(2)=(as*ra(2)+bs*rb(2))/g
      p(3)=(as*ra(3)+bs*rb(3))/g

c     pa^n and pb^n
      do j=1,3
        pan(0,j)=one
        pbn(0,j)=one
      end do
      if(MaxL .gt. 0)then
        do j=1,3
          pan(1,j)=p(j)-ra(j)
          pbn(1,j)=p(j)-rb(j)
        end do
        do i=2,MaxL
          do j=1,3
            pan(i,j)=pan(i-1,j)*pan(1,j)
            pbn(i,j)=pbn(i-1,j)*pbn(1,j)
          end do
        end do
      end if

      call integ(sx,MaxL,l1,l2,dgn,pan(0,1),pbn(0,1))
      call integ(sy,MaxL,m1,m2,dgn,pan(0,2),pbn(0,2))
      call integ(sz,MaxL,n1,n2,dgn,pan(0,3),pbn(0,3))
      s=s*sx*sy*sz

9000  return
      end

c-----------------------------------------------------------------------
c---  get LQ according to its number of components
c-----------------------------------------------------------------------
      function LQuant(ncomp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      select case(ncomp)
        case(1)
          LQuant=0
        case(3)
          LQuant=1
        case(5,6)
          LQuant=2
        case(7,10)
          LQuant=3
        case(9,15)
          LQuant=4
        case default
          write(*,"(' Error in LQuant!')")
          stop
      end select

      return
      end

c-----------------------------------------------------------------------
c--- write $CONTRACT
c-----------------------------------------------------------------------
      subroutine wrctr(inbo,nshell,nexp,MaxL,lsph,ncomp,nprim,nptr,expn,
     & con,tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*10 tag(10)
      data tag/
     *'   NCOMP =','   NPRIM =','    NPTR =','          ','     EXP =',
     *'      CS =','      CP =','      CD =','      CF =','      CG ='/
      dimension ncomp(nshell),nprim(nshell),nptr(nshell),expn(nexp),
     & con(nexp)
      dimension tmp(nexp)

      write(inbo,"(' $CONTRACT')")
      write(inbo,"('  NSHELL =',i7)")nshell
      write(inbo,"('    NEXP =',i7)")nexp

      nstep=10
      call lines(nshell,nstep,nline,last)
c     NCOMP
      call iwrite(tag(1),tag(4),inbo,nline,last,nstep,ncomp)
c     NPRIM
      call iwrite(tag(2),tag(4),inbo,nline,last,nstep,nprim)
c     NPTR
      call iwrite(tag(3),tag(4),inbo,nline,last,nstep,nptr)

      nstep=4
      call lines(nexp,nstep,nline,last)
c     EXP
      call fwrite(tag(5),tag(4),inbo,nline,last,nstep,expn)
c     CS
      nl = 1
      call cpcon('S',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
      call fwrite(tag(6),tag(4),inbo,nline,last,nstep,tmp)
c     CP
      if(MaxL .ge. 1)then
        nl = 3
        call cpcon('P',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
        call fwrite(tag(7),tag(4),inbo,nline,last,nstep,tmp)
      end if
c     CD
      if(MaxL .ge. 2)then
        nl = 5
        if(lsph .eq. 0) nl = 6
        call cpcon('D',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
        call fwrite(tag(8),tag(4),inbo,nline,last,nstep,tmp)
      end if
c     CF
      if(MaxL .ge. 3)then
        nl = 7
        if(lsph .eq. 0) nl = 10
        call cpcon('F',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
        call fwrite(tag(9),tag(4),inbo,nline,last,nstep,tmp)
      end if
c     CG
      if(MaxL .ge. 4)then
        nl = 9
        if(lsph .eq. 0) nl = 15
        call cpcon('G',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
        call fwrite(tag(10),tag(4),inbo,nline,last,nstep,tmp)
      end if

      write(inbo,"(' $END')")

      return
      end

c-----------------------------------------------------------------------
c---  copy contraction coefficients of a give LQ from con1 to con2
c     and then multiply the normalization factors
c     nl: # Cartesian or spherical functions of LQ
c-----------------------------------------------------------------------
      subroutine cpcon(al,nl,nshell,nexp,ncomp,nprim,ex,con1,con2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension ncomp(nshell),nprim(nshell),ex(nexp),con1(nexp),
     & con2(nexp)
      character*1 al

      call AClear(nexp,con2)
      ip=0
      do i=1,nshell
        if(ncomp(i) .eq. nl)then
          do j=1,nprim(i)
            ip = ip + 1
            con2(ip) = con1(ip) * fnorm(ex(ip),al)
          end do
        else
          ip = ip + nprim(i)
        end if
      end do

      return
      end

c-----------------------------------------------------------------------
c---  write $BASIS
c-----------------------------------------------------------------------
      subroutine wrbas(inbo,nbas,nc,label)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*10 tag(3)
      data tag/'  CENTER =','   LABEL =','          '/
      dimension nc(nbas),label(nbas)

      write(inbo,"(' $BASIS')")

      nstep=10
      call lines(nbas,nstep,nline,last)
c     CENTER
      call iwrite(tag(1),tag(3),inbo,nline,last,nstep,nc)
c     LABEL
      call iwrite(tag(2),tag(3),inbo,nline,last,nstep,label)

      write(inbo,"(' $END')")

      return
      end

c-----------------------------------------------------------------------
c---  write real array in the format a, n*f
c-----------------------------------------------------------------------
      subroutine fwrite(tag1,tag2,io,nline,last,nstep,fvec)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*10 tag1,tag2,ac
      dimension fvec(*)

      idx=0
      do i=1,nline
        if(i.eq.1)then
          ac=tag1
        else
          ac=tag2
        end if
        if(i.lt.nline)then
          write(io,1110)ac,(fvec(j),j=idx+1,idx+nstep)
          idx=idx+nstep
        else
          write(io,1110)ac,(fvec(j),j=idx+1,idx+last)
        end if
      end do

      return

1110  format(a10,4e16.7)
      end

c-----------------------------------------------------------------------
c---  write integer array in the format a, n*i
c-----------------------------------------------------------------------
      subroutine iwrite(tag1,tag2,io,nline,last,nstep,ivec)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*10 tag1,tag2,ac
      dimension ivec(*)

      idx=0
      do i=1,nline
        if(i.eq.1)then
          ac=tag1
        else
          ac=tag2
        end if
        if(i.lt.nline)then
          write(io,1110)ac,(ivec(j),j=idx+1,idx+nstep)
          idx=idx+nstep
        else
          write(io,1110)ac,(ivec(j),j=idx+1,idx+last)
        end if
      end do

      return

1110  format(a10,10i7)
      end

c-----------------------------------------------------------------------
c--- count the number of lines
c-----------------------------------------------------------------------
      subroutine lines(n1,n2,nline,last)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      nline=n1/n2
      last=n2
      if(mod(n1,n2).ne.0)then
        last=mod(n1,n2)
        nline=nline+1
      end if

      return
      end

c-----------------------------------------------------------------------
c---  read contracted basis functions
c     Note: the sp shells have been saved separately.
c-----------------------------------------------------------------------
      subroutine RdConBF(igto,natm,nshell,nexp,nbas,lsph,ncomp,nprim,
     & nptr,ncshl,expn,con,nc,label)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension ncomp(nshell),nprim(nshell),nptr(nshell),ncshl(nshell),
     & expn(nexp),con(nexp),nc(nbas),label(nbas)
      character*1 lq

      iatm = 1
      ishell = 0
      iexp = 0
      ibas = 0
      rewind(igto)
      read(igto,*)    ! skip " 1  0"
      do while(.true.)
        read(igto,*)lq,ncon
        if(lq .eq. 'E')then
          iatm = iatm + 1
          if(iatm .gt. natm)then
            exit
          else
            read(igto,*)    ! skip " n  0"
            cycle
          end if
        end if

        ishell = ishell + 1
c
        nprim(ishell) = ncon
c
        if(ishell .gt. 1)then
          nptr(ishell) = nptr(ishell-1)+nprim(ishell-1)
        else
          nptr(ishell) = 1
        end if
c
        ncshl(ishell) = iatm
c
c     Pattern in MOLDEN format:
c      5D: D 0, D+1, D-1, D+2, D-2
c          255  252  253  254  251
c      6D: xx, yy, zz, xy, xz, yz
c          201 204 206 202 203 205
c      7F: F 0, F+1, F-1, F+2, F-2, F+3, F-3
c          351  352  353  354  355  356  357
c     10F: xxx, yyy, zzz, xyy, xxy, xxz, xzz, yzz, yyz, xyz
c          301  307  310  304  302  303  306  309  308  305
c      9G: G 0, G+1, G-1, G+2, G-2, G+3, G-3, G+4, G-4
c          451  452  453  454  455  456  457  458  459
c     15G: xxxx yyyy zzzz xxxy xxxz yyyx yyyz zzzx zzzy xxyy xxzz yyzz xxyz yyxz zzxy
c          401  411  415  402  403  407  412  410  414  404  406  413  405  408  409
c
c     Labels used in NBO (see Section B.7.5 of the manual)
c
c     s     x     y     z                                               !  4 * cart s, p
c     001   101   102   103
c
c     s     px    py    pz                                              !  4 * pure s, p
c     001   101   102   103
c
c     xx    xy    xz    yy    yz    zz                                  !  6 * cart d
c     201   202   203   204   205   206
c
c     d2-   d1+   d1-   d2+   d0                                        !  5 * pure d
c     251   252   253   254   255
c
c     xxx   xxy   xxz   xyy   xyz   xzz   yyy   yyz   yzz   zzz         ! 10 * cart f
c     301   302   303   304   305   306   307   308   309   310
c
c     f0    f1+   f1-   f2+   f2-   f3+   f3-                           !  7 * pure f
c     351   352   353   354   355   356   357
c
c     xxxx  xxxy  xxxz  xxyy  xxyz  xxzz  xyyy  xyyz  xyzz  xzzz        ! 15 * cart g
c     yyyy  yyyz  yyzz  yzzz  zzzz
c     401   402   403   404   405   406   407   408   409   410
c     411   412   413   414   415
c
c     g0    g1+   g1-   g2+   g2-   g3+   g3-   g4+   g4-               !  9 * pure g
c     451   452   453   454   455   456   457   458   459
c
c     The real spherical harmonics are defined in
c     http://en.wikipedia.org/wiki/Table_of_spherical_harmonics
c
        if(lq .eq. 'S')then
          ncomp(ishell) = 1
          label(ibas + 1) = 001
        else if(lq .eq. 'P')then
          ncomp(ishell) = 3
          label(ibas + 1) = 101
          label(ibas + 2) = 102
          label(ibas + 3) = 103
        else if(lq .eq. 'D')then
          if(lsph .eq. 0) then
            ncomp(ishell) = 6
            label(ibas + 1) = 201
            label(ibas + 2) = 204
            label(ibas + 3) = 206
            label(ibas + 4) = 202
            label(ibas + 5) = 203
            label(ibas + 6) = 205
          else
            ncomp(ishell) = 5
            label(ibas + 1) = 255
            label(ibas + 2) = 252
            label(ibas + 3) = 253
            label(ibas + 4) = 254
            label(ibas + 5) = 251
          end if
        else if(lq .eq. 'F')then
          if(lsph .eq. 0) then
            ncomp(ishell) = 10
            label(ibas + 1) = 301
            label(ibas + 2) = 307
            label(ibas + 3) = 310
            label(ibas + 4) = 304
            label(ibas + 5) = 302
            label(ibas + 6) = 303
            label(ibas + 7) = 306
            label(ibas + 8) = 309
            label(ibas + 9) = 308
            label(ibas +10) = 305
          else
            ncomp(ishell) = 7
            label(ibas + 1) = 351
            label(ibas + 2) = 352
            label(ibas + 3) = 353
            label(ibas + 4) = 354
            label(ibas + 5) = 355
            label(ibas + 6) = 356
            label(ibas + 7) = 357
          end if
        else if(lq .eq. 'G')then
          if(lsph .eq. 0) then
            ncomp(ishell) = 15
            label(ibas + 1) = 401
            label(ibas + 2) = 411
            label(ibas + 3) = 415
            label(ibas + 4) = 402
            label(ibas + 5) = 403
            label(ibas + 6) = 407
            label(ibas + 7) = 412
            label(ibas + 8) = 410
            label(ibas + 9) = 414
            label(ibas +10) = 404
            label(ibas +11) = 406
            label(ibas +12) = 413
            label(ibas +13) = 405
            label(ibas +14) = 408
            label(ibas +15) = 409
          else
            ncomp(ishell) = 9
            label(ibas + 1) = 451
            label(ibas + 2) = 452
            label(ibas + 3) = 453
            label(ibas + 4) = 454
            label(ibas + 5) = 455
            label(ibas + 6) = 456
            label(ibas + 7) = 457
            label(ibas + 8) = 458
            label(ibas + 9) = 459
          end if
        end if
c
        do i=1,ncomp(ishell)
          ibas = ibas + 1
          nc(ibas) = iatm
        end do
c       basis functions in igto have been normalized
        do i=1,ncon
          iexp = iexp + 1
          read(igto,*)expn(iexp),con(iexp)
        end do
      end do

      return
      end

c-----------------------------------------------------------------------
c---  collects information of contracted basis functions
c     Note: the sp shells have been saved separately.
c-----------------------------------------------------------------------
      subroutine cbsinf(igto,natm,nshell,nexp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*1 lq

      iatm = 1
      nshell = 0
      nexp = 0
      rewind(igto)
      read(igto,*)    ! skip " 1  0"
      do while(.true.)
        read(igto,*)lq,ncon
        if(lq .eq. 'E')then
          iatm = iatm + 1
          if(iatm .gt. natm)then
            exit
          else
            read(igto,*)    ! skip " n  0"
            cycle
          end if
        end if

        nshell = nshell + 1
        nexp = nexp + ncon
        do i=1,ncon
          read(igto,*)
        end do
      end do

      return
      end

c-----------------------------------------------------------------------
c--- search [Program] and get the name of the program.
c--- [Program] is a special keyword for Molden2AIM.
c--- iname = 0 (default), 1 (orca), 2 (cfour), 3 (turbomole), ...
c--- < 0: same as 0 except the name of QC program is known.
c---
c--- If MOLCAS uses spherical functions, iname will be reset to -6 later.
c-----------------------------------------------------------------------
      subroutine getprog(imod,nprog,pname,iname)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp1,tmp2
      character*20 pname(nprog)
1010  format(' >>> This MOLDEN file was generated by ',a,/)

c     iname is known
      if(iname .ge. 1 .and. iname .le. nprog) then
        write(*,1010)trim(pname(iname))
        return
      end if

c     iname is unknown
      iname = 0
      rewind(imod)
100   read(imod,"(100a)",end=9999)tmp1
      call charl2u(tmp1,100)
      if(index(tmp1,'[PROGRAM]').ne.0) goto 200
      goto 100
200   read(imod,"(100a)",end=9999)tmp2
      call charl2u(tmp2,100)
c     FORMAT:
c     [PROGRAM] pname
c          or
c     [PROGRAM]
c       pname

      do i=1,nprog
        if(index(tmp1,trim(pname(i))).ne.0 .or.
     &     index(tmp2,trim(pname(i))).ne.0)then
          iname=i
          write(*,1010)trim(pname(iname))
          exit
        end if
      end do

9999  return
      end

c-----------------------------------------------------------------------
c---  Check the NBO's .47 file
c-----------------------------------------------------------------------
      subroutine CheckNBO(inbo,NAtom,NC,TotE1,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(tole=5.d-5,tola=1.d-6)
      dimension S(NC*(NC+1)/2),P(NC*(NC+1)/2)
      character*100 ctmp

      info=1
      NTT=NC*(NC+1)/2

c---  read S & P from the *.47 file
      rewind(inbo)
      do while(.true.)
        read(inbo,"(a100)",err=5000,end=5000)ctmp
        if(index(ctmp,"$OVERLAP") .ne. 0) then
          write(*,6010)
          read(inbo,*,err=5000,end=5000)(S(i),i=1,NTT)
        else if(index(ctmp,"$DENSITY") .ne. 0) then
          write(*,6020)
          read(inbo,*,err=5000,end=5000)(P(i),i=1,NTT)
          exit
        end if
      end do

      TotE2 = TracLL(NC,S,P)

      DifE=abs(TotE1-TotE2)
      DifA=DifE/dble(NAtom)
      write(*,6110)TotE1
      write(*,6120)TotE2
      write(*,6130)DifE,DifA
      if(NAtom .lt. 30) then
        if(DifE .gt. tole) write(*,6210)
      else
        if(DifA .gt. tola) write(*,6210)
      end if

      info=0

5000  return

6010  format(/,"  Reading overlap matrix...")
6020  format("  Reading density matrix...")
6110  format(/,"  Sum of MO Occupancies",22x," = ",f18.10)
6120  format("  Analytically integrated number of electrons = ",f18.10)
6130  format("  Difference",33x," = ",f18.10,/,
     &"  Difference per atom",24x," = ",f18.10)
6210  format(/,' ### Warning! Normalization check failed.')
      end

c-----------------------------------------------------------------------
c---  Check the AIM-WFN file
c-----------------------------------------------------------------------
      subroutine CheckWFN(MaxAtm,maxpg,MaxL,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(tole=5.d-5,tola=1.d-6)
      dimension r(3,MaxAtm),Expon(maxpg),CMO(maxpg),FNor(maxpg),
     & ICent(maxpg),IType(maxpg),smat(maxpg*(1+maxpg)/2)

      info=0

c---  read basis function from the *.WFN file
      write(*,6010)
      call RdBas(MaxAtm,maxpg,NMO,NGauss,NAtom,r,Expon,ICent,IType,FNor,
     &  info)
        if(info.ne.0) goto 5000
c---  compute the overlap matrix
      write(*,6020)
      call OvDriver(smat,NGauss,IType,Expon,r,ICent,MaxL,info)
        if(info.ne.0) goto 5000
c      call PrtMtr(NGauss, (NGauss*(NGauss+1)/2), 1, smat)

c---  compute the number of electrons
      write(*,6030)
      TotE1=0.d0
      TotE2=0.d0
      do i=1,NMO
        call RdMO(NGauss,Occ,CMO,FNor)
        TotE1=TotE1+Occ
        TotE2=TotE2+Occ*VSV(NGauss,CMO,smat)
      end do

      DifE=abs(TotE1-TotE2)
      DifA=DifE/dble(NAtom)
      write(*,6110)TotE1
      write(*,6120)TotE2
      write(*,6130)DifE,DifA
      if(NAtom .lt. 30) then
        if(DifE .gt. tole) write(*,6210)
      else
        if(DifA .gt. tola) write(*,6210)
      end if

5000  return

6010  format(/,"  Reading basis functions...")
6020  format("  Computing the overlap matrix...")
6030  format("  Computing the integrated number of electrons...")
6110  format(/,"  Sum of MO Occupancies",22x," = ",f18.10)
6120  format("  Analytically integrated number of electrons = ",f18.10)
6130  format("  Difference",33x," = ",f18.10,/,
     &"  Difference per atom",24x," = ",f18.10)
6210  format(/,' ### Warning! Normalization check failed.')
      end

c-----------------------------------------------------------------------
c---  v * S * v', S is a symmetric L.T. matrix
c-----------------------------------------------------------------------
      function VSV(N,v,s)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension v(N),s(*)

      p=0.d0
      do i=1,N
        k=IdxNTT(1,i)-1
        do j=1,i-1
          k=k+1
          q=v(j)*s(k)*v(i)
          p=p+q+q
        end do
        k=k+1
        q=v(i)*s(k)*v(i)
        p=p+q
      end do
      VSV=p

      return
      end

c-----------------------------------------------------------------------
c---  Trace of the product of lower triangular matrices A and B.
c-----------------------------------------------------------------------
      Function TracLL(N,A,B)
      Implicit Real*8(A-H,O-Z)
      Dimension A(*), B(*)

      Su = 0.0d0
      Do I = 1, N
        II = (I*(I-1))/2
        Do J = 1, I-1
          Su = Su + (A(II+J)+A(II+J))*B(II+J)
        End Do
        Su = Su + A(II+I)*B(II+I)
      End Do

      TracLL = Su
      Return
      End

c-----------------------------------------------------------------------
c---  It returns the position of element (J,I) in a L.T. matrix.
c     J must be .LE. I. It doesn't work if J > I.
c-----------------------------------------------------------------------
      Function IdxNTT(J,I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      IdxNTT=J+(I-1)*I/2

      Return
      End

c-----------------------------------------------------------------------
c--- read MO coefficients from the *WFN file
c-----------------------------------------------------------------------
      subroutine RdMO(NGauss,Occ,CMO,FNor)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension CMO(*),FNor(*)

      iwfn=46
      read(iwfn,"(34x,f13.7)")Occ
      read(iwfn,"(5d16.8)")(CMO(i),i=1,NGauss)
      do i=1,NGauss
        CMO(i)=CMO(i)/FNor(i)
      end do

      return
      end

c-----------------------------------------------------------------------
c--- driver of overlap matrix
c-----------------------------------------------------------------------
      subroutine OvDriver(s,NGauss,IType,Expon,r,ICent,MaxL,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension s(*),r(3,*),Expon(*),ICent(*),IType(*)

      k=0
      do i=1,NGauss
        do j=1,i
          k=k+1
          call overlap(s(k),IType(i),Expon(i),r(1,ICent(i)),
     *                      IType(j),Expon(j),r(1,ICent(j)),MaxL,info)
          if(info.ne.0) goto 100
        end do
      end do

100   return
      end

c-----------------------------------------------------------------------
c--- read basis function from the *.WFN file
c-----------------------------------------------------------------------
      subroutine RdBas(MaxAtm,MaxPG,NMO,NGauss,NAtom,r,Expon,ICent,
     &  IType,FNor,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension r(3,*),Expon(*),ICent(*),IType(*),FNor(*)

      iwfn=46
      info=0
      rewind(iwfn)
      read(iwfn,"(/,16x,i7,13x,i7,11x,i9)")NMO,NGauss,NAtom
      if(NAtom .ne. MaxAtm)then
        write(*,"(/,' ### Wrong! NAtom .ne. MaxAtm:',2i8)")NAtom,MaxAtm
        info=1
        goto 1000
      end if
      if(NGauss .ne. MaxPG)then
        write(*,"(/,' ### Wrong! NGauss .ne. MaxPG:',2i8)")NGauss,MaxPG
        info=1
        goto 1000
      end if

      do i=1,NAtom
        read(iwfn,"(24x,3f12.8)")r(1,i),r(2,i),r(3,i)
      end do

      read(iwfn,"(20x,20i3)")(ICent(i),i=1,NGauss)
      read(iwfn,"(20x,20i3)")(IType(i),i=1,NGauss)
      read(iwfn,"(10x,5d14.7)")(Expon(i),i=1,NGauss)

c---  compute normalization factors
      do i=1,NGauss
        FNor(i)=fnorm_lmn(Expon(i),IType(i))
      end do

1000  return
      end

c-----------------------------------------------------------------------
c--- check charge
c-----------------------------------------------------------------------
      subroutine chkcharge(nchar,sumocc,iprog,ifc4,iecp,ierr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      ierr=1
      write(*,"(//,' Warning: the total charge is different from the',
     *' sum of occupations!',//,2x,
     *' Total Charge=',f8.2,', Sum_OCC=',f8.2,', Net Charge=',f8.2,//,
     *' The reasons may be',/,
     *' 1) semi-empirical Hamiltonian or PP (including ECP and MCP)',
     *' is used,',/,
     *' 2) ionic system with Charge=',f8.2,','/,
c--- C4: RHF; Q-Chem: RHF, RDFT, ROGF, RODFT
     *' 3) beta occupations of R-SCF or RO-SCF are not printed by',
     *' CFOUR or Q-Chem,',/,
     *' or others.')")
     *dble(nchar),sumocc,dble(nchar)-sumocc,dble(nchar)-sumocc

      write(*,"(/,
     *' For 1), PP is not supported by WFN, but there is a way'
     *' by MultiWFN ...',/,
     *' For 2), it is not a matter,',/,
     *' For 3), occ. numbers should be multiplied by 2.0,',//,
     *' Which one corresponds to your case?',/,' > ',$)")

      read(*,*)ioc
      select case(ioc)
        case(1)
          write(*,"(/,' OK. Please read the MultiWFN manual ',
     *    '(Section 5.7) about how to do it.')")
          iecp=1
        case(2)
          docc=abs(ANINT(sumocc)-sumocc)
          if(docc.lt.1.d-4)then
            write(*,"(/,
     *      ' This is an ionic system with Charge=',f8.2)")
     *      dble(nchar)-sumocc
          else if(docc.lt.1.d-2)then
            write(*,"(/,' Warning! Strange occupation: ',f8.3)")sumocc
            write(*,"(/,' Please check your AIM results carefully.')")
          else
            write(*,"(/,' Error! Strange occupation: ',f8.3)")sumocc
            goto 9910
          end if
        case(3)
          write(*,"(///,' Occupations are multiplied by 2.0...')")
          ifc4=2
          charge=dble(nchar)-sumocc*dble(ifc4)
          write(*,"(/,
     *    '   Total Nuclear Charge = ',f8.2,/,
     *    '   Modified Sum_OCC     = ',f8.2,/,
     *    '   Net Charge           = ',f8.2,/)")
     *    dble(nchar),sumocc*dble(ifc4),charge
c--- for Q-Chem
          if(iprog .eq. 0)write(*,"(
     *    ' *** WARNING ***',/,
     *    '  There is a BUG in Q-Chem RO-SCF. In this case, please',
     *    ' correct the',/,
     *    '  occupation numbers of singly occupied MOs manually.')")
        case default
          write(*,"(/,' Unknown reason.')")
          goto 9910
      end select
      call xcontinue
      ierr=0

9910  return
      end

c-----------------------------------------------------------------------
c---  define file names
c-----------------------------------------------------------------------
      subroutine filename(inputFileName,imod,fwfn,fnbo)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*57 fwfn,fnbo,fmod(2)
      character*7 exten(6)
      character*50 inputFileName
      data exten
     */'.mol   ','.MOL   ','.mold  ','.MOLD  ','.molden','.MOLDEN'/

!!Lowdin comment the above lines
!!      write(*,"(///)")
!!100   write(*,"(' Type in the MOLDEN file name within 50 characters:',/,
!!     &' (extension mol/mold/molden can be omitted; default: MOLDEN)',/,
!!     &' > ',$)")
!!     read(*,"(a50)")fmod(1)(:)
      fmod(1)(:) = inputFileName
      lstr=nonspace(fmod(1)(:))
      lend=LEN_TRIM(fmod(1)(:))
      if(lend.eq.0)then                 ! use default file name
        lstr=1
        lend=6
        fmod(1)(1:6)='MOLDEN'
      end if
      open(imod,file=fmod(1)(lstr:lend),status='old',err=110)
      iinp=1
      goto 300
110   if(fmod(1)(lend:lend).eq.'.')lend=lend-1
      iinp=2
      do i=1,6
        fmod(2)(:)=fmod(1)(lstr:lend)//trim(exten(i))
        open(imod,file=fmod(2)(:),status='old',err=120)
        goto 300
120     continue
      end do
      write(*,"(//,' ### Wrong! These MOLDEN files do not exist!')")
      write(*,"(1x,a)")fmod(1)
      do i=1,6
        write(*,"(1x,a)")fmod(1)(lstr:lend)//trim(exten(i))
      end do
      write(*,"(/,' Please try again.',/)")
!!Lowdin comment the above line
!!      goto 100

300   write(*,"(/,' The MOLDEN file ',a,' has been found.',//)")
     *trim(fmod(iinp))
c---  define the *.wfn/wfx/47 file name
      lend2=index(fmod(iinp),'.',.true.)
      if(lend2 .gt. 1) lend = lend2-1
      fwfn=fmod(iinp)(lstr:lend)//'.wfn'
      fnbo=fmod(iinp)(lstr:lend)//'.47'

      return
      end

c-----------------------------------------------------------------------
c--- make sure that iprog matches with lsph
c-----------------------------------------------------------------------
      subroutine chkbstyp(lsph,iprog,MaxL,ierr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      ierr=0
      if(lsph.eq.0 .and. MaxL.gt.1 .and. iprog.eq.1)then
c--- orca: spherical b.s. is used; for Cartesian b.s. (in a future
c--- version?), you should do some tests.
        write(*,
     *"(' ### Wrong! ORCA does not use Cartesian b.s.!')")
        ierr=1
      else if(lsph.ne.0 .and. MaxL.gt.1 .and. iprog.eq.2)then
c--- cfour: Cartesian b.s. is used; for spherical b.s. (in a future
c--- version?), you should do some tests.
        write(*,
     *"(' ### Wrong! CFOUR does not print MOs in spherical b.s.!')")
        ierr=1
      else if(lsph.ne.0 .and. MaxL.gt.1 .and. iprog.eq.3)then
c--- turbomole: Cartesian b.s. is used; for spherical b.s. (in a future
c--- version?), you should do some tests.
        write(*,
     *"(' ### Wrong! TURBOMOLE does not print MOs in spherical b.s.!')")
        ierr=1
      else if(lsph.ne.0 .and. MaxL.gt.1 .and. iprog.eq.4)then
c--- jaguar: Cartesian b.s. is used; for spherical b.s. (in a future
c--- version?), you should do some tests.
        write(*,
     *"(' ### Wrong! Jaguar does not print MOs in spherical b.s.!')")
        ierr=1
      else if(lsph.ne.0 .and. MaxL.gt.1 .and. iprog.eq.5)then
c--- aces2: Cartesian b.s. is used; for spherical b.s. (in a future
c--- version?), you should do some tests.
        write(*,
     *"(' ### Wrong! ACES2 does not print MOs in spherical b.s.!')")
        ierr=1
      end if

      return
      end

c-----------------------------------------------------------------------
c--- print title
c-----------------------------------------------------------------------
      subroutine writitle(iwfn,fwfn,ver,dt)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*57 fwfn
      character*10 dt
      character*5 ver
      character*50 texdate

      OPEN(iwfn,FILE=fwfn)
      rewind(iwfn)

c--- if fdate doesn't work, just use this line
c      write(iwfn,"(' Molden2AIM, Version ',a5,' (',a10,')')")ver,dt
c---
      call fdate(texdate)
      call trulen(texdate,L1,L2,length)
      write(iwfn,"(' Molden2AIM, Version ',a5,' (',a10,')',11x,
     *'Time: ',a24)")ver,dt,texdate(L1:L2)
c---
      return
      end

c-----------------------------------------------------------------------
c--- print head
c-----------------------------------------------------------------------
      subroutine headprt(ver,dt)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*10 dt
      character*5 ver

      write(*,"(//,1x,77('*'),/
     *31x,            '*  Molden2AIM  *',/,
     *26x,       'Version ',a5,',  ',a10,/,
     *11x,'It converts the format from MOLDEN to AIM-WFN and NBO-47',/,
     *1x,77('*'),/)")ver,dt
      return
      end

c-----------------------------------------------------------------------
c--- print supporting information
c-----------------------------------------------------------------------
      subroutine SuppInf
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      write(*,"(
     &' Supported programs:',/,
     &'  1) MOLPRO',/,
     &'  2) MOLCAS (for Cart. functions, insert [PROGRAM] MOLCAS into',
     -    ' MOLDEN file)',/,
     &'  3) deMon2k',/,
     &'  4) Q-Chem (spherical SPDF or Cartesian SPD basis functions)',/,
     &'  5) CFour (fix reorderdf.F, and insert [PROGRAM] CFOUR into',
     -    ' MOLDEN file)',/,
     &'  6) Turbomole (insert [PROGRAM] TURBOMOLE into MOLDEN file)',/,
     &'  7) ORCA (insert [PROGRAM] ORCA into MOLDEN file)',/,
     &'  8) Columbus (Natural orb. from MCSCF or CI with Cartesian',
     -    ' SPDF functions;',/,
     &'     thanks to Dr. Marat Talipov for testing)',/,
     &'  9) Priroda (thanks to Dr. Evgeniy Pankratyev for testing)',/,
     &' 10) Dalton 2013 (HF/DFT/MP2/MCSCF with spherical functions)',/,
     &' 11) TeraChem (SPDF basis functions)',/,
     &' 12) ACES-II 2.9 (fix reorder.F, and insert [PROGRAM] ACES2',
     -    ' into MOLDEN file)',/,
     &' 13) NWChem (using JANPA/nwchem2molden to generate MOLDEN file)'
     -    ,/,
     &' 14) BDF (thanks to Dr. Bingbing Suo for testing)',/,
     &' 15) PSI4 (spherical functions only; insert [PROGRAM] PSI4 into',
     -    ' MOLDEN file)',/,
     &' 16) CADPAC',/,
     &' 17) MRCC (for Cart. functions, insert [PROGRAM] MRCC into',
     -    ' MOLDEN file)'
     &)")

      write(*,"(/,
     &' Programs to be tested:      1) StoBe      2) NRLMOL')")

      write(*,"(/,
     &' Unsupported programs:       1) ADF        2) Jaguar')")

      call xcontinue

      return
      end

c-----------------------------------------------------------------------
c---  generate a standard Molden file with Cartrsian basis functions.
c-----------------------------------------------------------------------
      subroutine genmdn(fwfn,inmd,iatm,igto,imol,imo0,ver,dt,nat,nmotot,
     &  ncarmo,ngc,ifc4)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      character*5 ver
      character*10 dt
      character*50 texdate
      character*57 fwfn
      character*64 fmdn
      character*100 tmp

      lenth=Len_trim(fwfn)-4
      fmdn=fwfn(1:lenth)//'_new.molden'

      OPEN(inmd,FILE=fmdn)
      rewind(inmd)

c---  title
      write(inmd,"('[Molden Format]')")
      write(inmd,"('[Title]')")
c     if fdate doesn't work, just use this line
c      write(inmd,"(' Molden2AIM, Version ',a5,' (',a10,')')")ver,dt
c
      call fdate(texdate)
      call trulen(texdate,L1,L2,length)
      write(inmd,"(' Molden2AIM, Version ',a5,' (',a10,')',11x,
     *'Time: ',a24)")ver,dt,texdate(L1:L2)
      write(inmd,*)

c---  coordinates
      rewind(iatm)
      read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
      if(iu .eq. 0) then
        write(inmd,"('[Atoms] Angs')")
      else
        write(inmd,"('[Atoms] AU')")
      end if

      do i=1,nat
        read(iatm,"(100a)")tmp
        write(inmd,"(100a)")trim(tmp)
      end do
c     the blank line before [GTO] is not allowed by MOLDEN!!!
ccc      write(inmd,*)

c---  basis functions
      rewind(igto)
      write(inmd,"('[GTO]')")
200   read(igto,"(100a)",end=300)tmp
      if(Len_trim(tmp) .eq. 0) goto 200
      if(index(tmp,' E 0').ne.0)then
        write(inmd,*)
      else
        write(inmd,"(100a)")trim(tmp)
      end if
      goto 200
300   write(inmd,*)

c---  MO in Cartesian basis functions
      rewind(imol)
      rewind(imo0)
      write(inmd,"('[MO]')")
      do i=1,nmotot
c       read "Sym=", "Ene=", "Spin=", and "Occup=" from imo0
c       Gabedit doesn't recognize UPPERCASE keywords!
600     read(imo0,"(100a)")tmp
        j=index(tmp,'=')
        if(j.ne.0)then
          call charl2u(tmp,j-1)
c         Occup=
          if(index(tmp(1:j-1),'OCCUP').ne.0)then
            read(tmp(j+1:),*)x
            write(inmd,"(' Occup=',f18.8)")x*dble(ifc4)
c         Ene=
          else if(index(tmp(1:j-1),'ENE').ne.0)then
            read(tmp(j+1:),*)x
            write(inmd,"(' Ene=',f20.8)")x
c         Sym=
          else if(index(tmp(1:j-1),'SYM').ne.0)then
            write(inmd,"(' Sym=',a)")trim(tmp(j+1:))
c         Spin=
          else if(index(tmp(1:j-1),'SPIN').ne.0)then
            if(index(tmp(j+1:),'ALPHA').ne.0)then
              write(inmd,"(' Spin= Alpha')")
            else
              write(inmd,"(' Spin= Beta')")
            end if
          else
            write(inmd,"(100a)")trim(tmp)
          end if

          goto 600
        end if

        do j=1,ncarmo-1
          read(imo0,*)
        end do
c       read MO coefficients from imol
        read(imol,*)
        read(imol,*)
        do j=1,ngc
          read(imol,*)idx,cf
          write(inmd,"(i5,f20.10)")idx,cf*scalmo(j)
        end do
      end do
      write(inmd,*)

      write(*,"(//,
     *'  A new Molden file is generated successfully!',/,
     *'  File Name = ',a)")trim(fmdn)

      return
      end

c-----------------------------------------------------------------------
c--- print information at the final step for wfn
c-----------------------------------------------------------------------
      subroutine finalwfn(fwfn,iecp,MaxL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*57 fwfn

      write(*,"(//,
     &'  A WFN file is generated successfully!',/,
     &'  File Name = ',a)")trim(fwfn)
      if(iecp .ne. 0)then
        write(*,"(/,2x,
     &'Because of PP (ECP or MCP), please use',/,3x,
     &'MultiWFN 3.2.1 or higher version',/)")
      else if(MaxL .lt. 4)then
        write(*,"(/,2x,
     &'Please use',/,3x,
     &'AIM2000, AIMALL, AIMPAC, AIMPAC2, AIM-UC, CheckDen, DGrid, ',
     -'MORPHY,',/,3x,
     &'MultiWFN, PAMoC, ProMolden, TopChem, TopMoD, or XAIM',/)")
      else
        write(*,"(/,2x,
     &'G-functions are found! Please use',/,3x,
     &'AIM2000 (Ver. 2013), AIMALL, AIM-UC, DGrid, MultiWFN, or ',
     -'TopChem',/)")
      end if
      write(*,"('  to analyse the electron density distribution.')")

      return
      end

c-----------------------------------------------------------------------
c--- print information at the final step for nbo's 47 file
c-----------------------------------------------------------------------
      subroutine finalnbo(fnbo,MaxL,iecp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*57 fnbo

      write(*,"(//,
     &'  A NBO 47 file is generated successfully!',/,
     &'  File Name = ',a)")trim(fnbo)

      if(MaxL .gt. 3) write(*,"(/,
     &' Warning: because of G-functions, NBO 3.0 does not work.',/,
     &' Higher versions of the NBO program should be used.')")

c     IZ(2) will be modified automatically in future.
      if(iecp .ne. 0) write(*,"(/,
     &' Since ECP is used, IZ(2) in $COORD has to be corrected',
     -' manually. For example,',//,
     &' $COORD',/,
     &' AuH',/,
     &'     79    19       0.000000       0.000000       0.021250',/,
     &'           ~~ <---- IZ(2) = IZ(1) - #core electrons = 79 - 60',/,
     &'      1     1       0.000000       0.000000      -1.678750')")

      return
      end

c-----------------------------------------------------------------------
c--- A new version of the subroutine checkcar for shortened MO arrays.
c--- Count the number of basis functions from MO, which can be used to
c--- judge cartesian/spherical basis functions.
c-----------------------------------------------------------------------
      subroutine checkcar2(nc,ishort,ifmo)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp

      imod=44
      nc=0
      ifmo=1
      ishort=0
      maxnc=0
      iold=0

c--- count the number of CGTO
      rewind(imod)

500   read(imod,"(100a)",end=550)tmp
      call charl2u(tmp,100)
      if(index(tmp,'[MO]').ne.0) goto 600
      goto 500

550   write(*,*)"*** Wrong! [MO] can not be found!"
      ifmo=0
      return

600   read(imod,"(100a)",end=9999)tmp
      if(len_trim(tmp).eq.0) goto 600
c      call charl2u(tmp,100)
      if(index(tmp,'=').ne.0) goto 600
      if(index(tmp,'[').ne.0) goto 9999

      nc=0
610   read(tmp,*)inew
      nc=nc+1
      maxnc=max(maxnc,inew)
620   read(imod,"(100a)",end=9990)tmp
      if(len_trim(tmp).eq.0) goto 620
      if(index(tmp,'=').ne.0)then
        if(nc .lt. maxnc) ishort=1
        goto 600
      end if
      if(index(tmp,'[').ne.0) goto 9990
      goto 610

9990  if(nc .lt. maxnc) ishort=1
9999  nc=maxnc

      return
      end

cc-----------------------------------------------------------------------
cc--- count the number of basis functions from MO, which can be used to
cc--- judge Cartesian/spherical basis functions.
cc-----------------------------------------------------------------------
c      subroutine checkcar(nc,ifmo)
c      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c      character*100 tmp
c
c      imod=44
c      nc=0
c      ifmo=1
c
cc--- Dalton prints spherical basis functions by default in the MOLDEN
cc--- file, but the keywords [5d], [7f], and [9g] are not specified.
cc      rewind(imod)
cc
cc100   read(imod,"(100a)",end=200)tmp
cc      call charl2u(tmp,100)
cc      if(index(tmp,'[').ne.0 .and. index(tmp,']').ne.0) then
cc        if( index(tmp,'[5D').ne.0 .or. index(tmp,'[7F').ne.0 .or.
cc     *      index(tmp,'[9G').ne.0 ) goto 9999
cc      end if
cc      goto 100
cc200   continue
c
cc--- count the number of CGTO
c      rewind(imod)
c
c500   read(imod,"(100a)",end=550)tmp
c      call charl2u(tmp,100)
c      if(index(tmp,'[MO]').ne.0) goto 600
c      goto 500
c
c550   write(*,*)"*** Wrong! [MO] can not be found!"
c      ifmo=0
c      return
c
c600   read(imod,"(100a)",end=9999)tmp
c      call charl2u(tmp,100)
c      if(index(tmp,'OCCUP').ne.0) goto 700
c      goto 600
c
c700   read(imod,"(100a)",end=9999)tmp
cc      call charl2u(tmp,100)
c      if(index(tmp,'[').ne.0 .or. index(tmp,'=').ne.0 .or.
c     *   len_trim(tmp).eq.0) then
c        goto 9999
c      else
c        nc=nc+1
c        goto 700
c      end if
c
c9999  continue
c
c      return
c      end

c-----------------------------------------------------------------------
c--- write MO.s to the *.wfn file
c-----------------------------------------------------------------------
      subroutine writemol(iwfn,imol,nmo,ng,ngc,tolocc,ifc4)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      character*10 tmp

c--- normalization factor
      do i=1,ng
        cn(i)=fnorm_lmn(expg(i),ityp(i))
      end do

      rewind(imol)
      do i=1,nmo
        read(imol,*)tmp,occ
        read(imol,*)tmp,eng
        do j=1,ngc
          read(imol,*)ingc,cfmo(j)
          cfmo(j)=cfmo(j)*scalmo(j)
        end do
        if(abs(occ) .ge. tolocc)then
          if(abs(eng).lt.9999.d0)then
            write(iwfn,1000)i,occ*dble(ifc4),eng
          else
            write(iwfn,1100)i,occ*dble(ifc4),eng
          end if
c---      N*cgto*cmo
          write(iwfn,"(5d16.8)")
     *      (cn(j)*conf(j)*cfmo(icmo(j)),j=1,ng)
        end if
      end do

1000  format("MO",i5,5x,"MO 0.0",8x,"OCC NO =",f13.7,"  ORB. ENERGY =",
     *f12.6)
1100  format("MO",i5,5x,"MO 0.0",8x,"OCC NO =",f13.7,"  ORB. ENERGY =",
     *f12.4)

      return
      end

c-----------------------------------------------------------------------
c---  calculate the normalization factor for GTO(l,m,n)
c---  it = 1,...,35
c---  Ordering type:
c---  S,P,D: MOLDEN, Gaussian, GAMESS, WFN, ...
c---  F: WFN (for MOLDEN and Gaussian, 14~19 are different)
c---  G: WFN, MOLDEN (not for Gaussian)
c-----------------------------------------------------------------------
      function fnorm_lmn(a,it)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      pi=acos(-1.d0)
      pi3=pi**3.d0

      select case(it)
        case(1)            ! 1S
          n1=3
          n2=3
          nf=1
        case(2:4)          ! 3P: x, y, z
          n1=7
          n2=5
          nf=1
        case(5:10)         ! 6D
          n1=11
          n2=7
          select case(it)
            case(5:7)        ! xx, yy, zz
              nf=9
            case(8:10)       ! xy, xz, yz
              nf=1
          end select
        case(11:20)        ! 10F
          n1=15
          n2=9
          select case(it)
            case(11:13)      ! xxx, yyy, zzz
              nf=225
            case(14:19)      ! xxy, xxz, yyz, xyy, xzz, yzz
              nf=9
            case(20)         ! xyz
              nf=1
          end select
        case(21:35)        ! 15G
          n1=19
          n2=11
          select case(it)
            case(21:23)      ! xxxx yyyy zzzz
              nf=11025
            case(24:29)      ! xxxy xxxz yyyx yyyz zzzx zzzy
              nf=225
            case(30:32)      ! xxyy xxzz yyzz
              nf=81
            case(33:35)      ! xxyz yyxz zzxy
              nf=9
          end select
cc<<<     Gaussian (subroutine pattml should also be modified)
c          select case(it)
c            case(21,25,35)               ! xxxx yyyy zzzz
c              nf=11025
c            case(22,24,26,29,33,34)      ! xxxy xxxz yyyx yyyz zzzx zzzy
c              nf=225
c            case(23,30,32)               ! xxyy xxzz yyzz
c              nf=81
c            case(27,28,31)               ! xxyz yyxz zzxy
c              nf=9
c          end select
cc>>>
      end select

c--- Normal^4 = 2^n1 * a^n2 / (pi^3 * nf)
c---   n1=3+4*(l+m+n)
c---   n2=3+2*(l+m+n)
c---   nf=[(2l-1)!!(2m-1)!!(2n-1)!!]^2
      f = (2.d0**dble(n1)) * (a**dble(n2)) / (pi3 * dble(nf))
      fnorm_lmn=sqrt(sqrt(f))

      return
      end

c-----------------------------------------------------------------------
c--- write atoms, coordinates, and basis functions to the *.wfn file
c-----------------------------------------------------------------------
      subroutine writecnt(iwfn,igto,imol,npg)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      character*1 al
      character*10 tmp

      rewind(igto)
      rewind(imol)
      ipt1=0
      ipt2=0

      read(imol,*)tmp,occ
      read(imol,*)tmp,eng
100   read(igto,*,end=500)ic1
200   read(igto,*)al,np
      if(al.eq.'E'.and.np.eq.0)goto 100
      do i=1,np
        read(igto,*)expgc(i),confc(i)
      end do
      select case(al)
        case('S')
          nfun=1
          it=0
        case('P')
          nfun=3
          it=1
        case('D')
          nfun=6
          it=4
        case('F')
          nfun=10
          it=10
        case('G')
          nfun=15
          it=20
      end select
      do i=1,nfun
        ipt1=ipt2+1
        ipt2=ipt1+np-1
        it=it+1
        expg(ipt1:ipt2)=expgc(1:np)
        conf(ipt1:ipt2)=confc(1:np)
        icnt(ipt1:ipt2)=ic1
        do j=ipt1,ipt2
          if(it.ge.14.and.it.le.19)then
! f: xyy, xxy, xxz, xzz, yzz, yyz (MOLDEN or Gaussian-out) -->
!    xxy, xxz, yyz, xyy, xzz, yzz (Gaussian-WFN or GAMESS-WFN)
            ityp(j)=iorder(it)
          else
            ityp(j)=it
          end if
        end do
c--- read MO coeff. index
        read(imol,*)igc
        icmo(ipt1:ipt2)=igc
      end do
      goto 200

500   continue

      write(iwfn,"('CENTRE ASSIGNMENTS  ',20i3)")(icnt(i),i=1,npg)
      write(iwfn,"('TYPE ASSIGNMENTS    ',20i3)")(ityp(i),i=1,npg)
      write(iwfn,"('EXPONENTS ',5d14.7)")(expg(i),i=1,npg)

      return
      end

c-----------------------------------------------------------------------
c--- reorder f-functions from MOLDEN to WFN.
c-----------------------------------------------------------------------
      function iorder(n)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      select case(n)
        case(14)
          iorder=17
        case(15)
          iorder=14
        case(16)
          iorder=15
        case(17)
          iorder=18
        case(18)
          iorder=19
        case(19)
          iorder=16
      end select

      return
      end

c-----------------------------------------------------------------------
c--- read an <ENTER> to continue
c-----------------------------------------------------------------------
      subroutine xcontinue
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

!!Lowdin comment the above lines
!!      write(*,"(/,' Press <ENTER> to continue')")
!!      read(*,*)

      return
      end

c-----------------------------------------------------------------------
c--- read an <ENTER> and stop
c-----------------------------------------------------------------------
      subroutine estop
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)


!!Lowdin comment the above lines
!!      write(*,"(//,' Press <ENTER> to exit',/)")
!!      read(*,*)

!!      stop

      return
      end

c-----------------------------------------------------------------------
c--- print spin of MO
c    ispn    0: n.a.     1: alpha or alpha+beta    2: beta
c    iwfn    1: alpha    2: beta    3: alpha+beta
c-----------------------------------------------------------------------
      subroutine writespn(iwfn,ispn,ifbeta,NMO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(ncol=40)
      dimension is(ncol)

      rewind(ispn)
      write(iwfn,"(//,' $MOSPIN $END')")

      nline=NMO/ncol
      nlast=mod(NMO,ncol)

      do j=1,ncol
        is(j)=3
      end do
      do i=1,nline
        if(ifbeta.eq.1) read(ispn,*)(is(j),j=1,ncol)
        write(iwfn,"(40i2)")is(1:ncol)
      end do

      if(nlast.gt.0)then
        if(ifbeta.eq.1) read(ispn,*)(is(j),j=1,nlast)
        write(iwfn,"(40i2)")is(1:nlast)
      end if
      write(iwfn,"(/)")

      return
      end

c-----------------------------------------------------------------------
c--- write coordinates to WFN.
c-----------------------------------------------------------------------
      subroutine writeatm(iwfn,iatm,nat)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter (maxza=112,au2ang=0.529177249d0)
      character*3 am,atomlib(maxza)
      data (atomlib(i),i=1,50) /
     1'H  ','He ','Li ','Be ','B  ','C  ','N  ','O  ','F  ','Ne ',
     2'Na ','Mg ','Al ','Si ','P  ','S  ','Cl ','Ar ','K  ','Ca ',
     3'Sc ','Ti ','V  ','Cr ','Mn ','Fe ','Co ','Ni ','Cu ','Zn ',
     4'Ga ','Ge ','As ','Se ','Br ','Kr ','Rb ','Sr ','Y  ','Zr ',
     5'Nb ','Mo ','Tc ','Ru ','Rh ','Pd ','Ag ','Cd ','In ','Sn '/
      data (atomlib(i),i=51,100) /
     6'Sb ','Te ','I  ','Xe ','Cs ','Ba ','La ','Ce ','Pr ','Nd ',
     7'Pm ','Sm ','Eu ','Gd ','Tb ','Dy ','Ho ','Er ','Tm ','Yb ',
     8'Lu ','Hf ','Ta ','W  ','Re ','Os ','Ir ','Pt ','Au ','Hg ',
     9'Tl ','Pb ','Bi ','Po ','At ','Rn ','Fr ','Ra ','Ac ','Th ',
     A'Pa ','U  ','Np ','Pu ','Am ','Cm ','Bk ','Cf ','Es ','Fm '/
      data (atomlib(i),i=101,maxza) /
     B'Md ','No ','Lr ','Rf ','Db ','Sg ','Bh ','Hs ','Mt ','Ds ',
     C'Rg ','Cn '/

      fc=1.d0
      rewind(iatm)
      read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
      if(iu.eq.0)fc=1.d0/au2ang

      do i=1,nat
        read(iatm,*)am,ia,iz,x,y,z
        if(iz.gt.0 .and. iz.le.maxza) am=atomlib(iz)
        write(iwfn,100)am,i,i,x*fc,y*fc,z*fc,dble(iz)
      end do

100   format(2x,A3,i3,4x,'(CENTRE',i3,') ',3f12.8,'  CHARGE =',f5.1)

      return
      end

c-----------------------------------------------------------------------
c--- spherical MO --> Cartesian MO
c-----------------------------------------------------------------------
      subroutine sph2car(lq,fi,fo)
      implicit double precision (a-h,o-z)
c--- input & output MO factors
      dimension fi(9),fo(15)
c--- map relationship between pure and Cartesian basis functions
      common/carsph/dmap(6,5),fmap(10,7),gmap(15,9)
      parameter(
     *    c375 = 0.375d0,
     *    r3_4 = 0.8660254038d0,        ! sqrt(3/4)
     *    r5_4 = 1.1180339887d0,        ! sqrt(5/4)
     *    r6_5 = 1.0954451150d0,        ! sqrt(6/5)
     *    r9_7 = 1.1338934190d0,        ! sqrt(9/7)
     *   r10_7 = 1.1952286093d0,        ! sqrt(10/7)
     *    r5_8 = 0.7905694150d0,        ! sqrt(5/8)
     *    r9_8 = 1.0606601718d0,        ! sqrt(9/8)
     *   r5_16 = 0.5590169944d0,        ! sqrt(5/16)
     *  r27_28 = 0.9819805061d0,        ! sqrt(27/28)
     *  r35_64 = 0.7395099729d0,        ! sqrt(35/64)
     * r27_560 = 0.2195775164d0,        ! sqrt(27/560)
     *    v3_4 =-0.8660254038d0,        !-sqrt(3/4)
     *    v5_4 =-1.1180339887d0,        !-sqrt(5/4)
     *    v3_8 =-0.6123724357d0,        !-sqrt(3/8)
     *    v5_8 =-0.7905694150d0,        !-sqrt(5/8)
     *    v9_8 =-1.0606601718d0,        !-sqrt(9/8)
     *   v5_16 =-0.5590169944d0,        !-sqrt(5/16)
     *  v27_16 =-1.2990381057d0,        !-sqrt(27/16)
     *   v9_20 =-0.6708203932d0,        !-sqrt(9/20)
     *   v5_28 =-0.4225771274d0,        !-sqrt(5/28)
     *  v27_28 =-0.9819805061d0,        !-sqrt(27/28)
     *  v27_35 =-0.8783100657d0,        !-sqrt(27/35)
     *   v3_40 =-0.2738612788d0,        !-sqrt(3/40)
     *   v9_56 =-0.4008918629d0,        !-sqrt(9/56)
     *  v45_56 =-0.8964214570d0)        !-sqrt(45/56)

c--- In pure basis functions, MOLDEN ordering is used.
c--- In Cartesian basis functions, MOLDEN order is used and will be
c---   re-ordered in subroutine writecnt.
c--- Ref. subroutine purdf in espot.f of MOLDEN 4.8. The result agrees
c---   with that of MOLPRO.

      data ((dmap(j,i),j=1,6),i=1,5) /
c  6D:     xx      yy      zz      xy      xz      yz                            5D:
     * -0.5d0, -0.5d0,  1.0d0,  0.0d0,  0.0d0,  0.0d0,                         ! d0  = zz-(xx+yy)/2
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  1.0d0,  0.0d0,                         ! d+1 = xz
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  1.0d0,                         ! d-1 = yz
     *   r3_4,   v3_4,  0.0d0,  0.0d0,  0.0d0,  0.0d0,                         ! d+2 = r3_4*(xx-yy)
     *  0.0d0,  0.0d0,  0.0d0,  1.0d0,  0.0d0,  0.0d0/                         ! d-2 = xy

      data ((fmap(j,i),j=1,10),i=1,7) /
c 10F:    xxx     yyy     zzz     xyy     xxy     xxz     xzz     yzz
c         yyz     xyz                                                            7F
     *  0.0d0,  0.0d0,  1.0d0,  0.0d0,  0.0d0,  v9_20,  0.0d0,  0.0d0,
     *  v9_20,  0.0d0,                                                         ! f0  = zzz-(xxz+yyz)*sqrt(9/20)
     *   v3_8,  0.0d0,  0.0d0,  v3_40,  0.0d0,  0.0d0,   r6_5,  0.0d0,
     *  0.0d0,  0.0d0,                                                         ! f+1 = -xxx*sqrt(3/8)-xyy*sqrt(3/40)+xzz*sqrt(6/5)
     *  0.0d0,   v3_8,  0.0d0,  0.0d0,  v3_40,  0.0d0,  0.0d0,   r6_5,
     *  0.0d0,  0.0d0,                                                         ! f-1 = -yyy*sqrt(3/8)-xxy*sqrt(3/40)+yzz*sqrt(6/5)
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   r3_4,  0.0d0,  0.0d0,
     *   v3_4,  0.0d0,                                                         ! f+2 = (xxz-yyz)*sqrt(3/4)
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0,  1.0d0,                                                         ! f-2 = xyz
     *   r5_8,  0.0d0,  0.0d0,   v9_8,  0.0d0,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0,  0.0d0,                                                         ! f+3 = xxx*sqrt(5/8)-xyy*sqrt(9/8)
     *  0.0d0,   v5_8,  0.0d0,  0.0d0,   r9_8,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0,  0.0d0/                                                         ! f-3 = yyy*sqrt(5/8)-xxy*sqrt(9/8)

      data ((gmap(j,i),j=1,15),i=1,9) /
c 15G:   xxxx    yyyy    zzzz    xxxy    xxxz    yyyx    yyyz    zzzx
c        zzzy    xxyy    xxzz    yyzz    xxyz    yyxz    zzxy                    9G
     *   c375,   c375,  1.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0,r27_560, v27_35, v27_35,  0.0d0,  0.0d0,  0.0d0,                 ! g0  = (xxxx+yyyy)*c375+zzzz+xxyy*r27_560+(xxzz+yyzz)*v27_35
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0, v45_56,  0.0d0,  0.0d0,  r10_7,
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  v9_56,  0.0d0,                 ! g+1 = xzzz*r10_7+xxxz*v45_56+yyxz*v9_56
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0, v45_56,  0.0d0,
     *  r10_7,  0.0d0,  0.0d0,  0.0d0,  v9_56,  0.0d0,  0.0d0,                 ! g-1 = yzzz*r10_7+yyyz*v45_56+xxyz*v9_56
     *  v5_16,  r5_16,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0,  0.0d0, r27_28, v27_28,  0.0d0,  0.0d0,  0.0d0,                 ! g+2 = -(xxxx-yyyy)*r5_16+(xxzz-yyzz)*r27_28
     *  0.0d0,  0.0d0,  0.0d0,  v5_28,  0.0d0,  v5_28,  0.0d0,  0.0d0,
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   r9_7,                 ! g-2 = (xxxy+xyyy)*v5_28+zzxy*r9_7
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,   r5_8,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   v9_8,  0.0d0,                 ! g+3 = xxxz*r5_8+yyxz*v9_8
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   v5_8,  0.0d0,
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,   r9_8,  0.0d0,  0.0d0,                 ! g-3 = yyyz*v5_8+xxyz*r9_8
     * r35_64, r35_64,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0, v27_16,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,                 ! g+4 = (xxxx+yyyy)*r35_64+xxyy*v27_16
     *  0.0d0,  0.0d0,  0.0d0,   r5_4,  0.0d0,   v5_4,  0.0d0,  0.0d0,
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0/                 ! g-4 = (xxxy-xyyy)*r5_4

      fo=0.d0
      select case(lq)
        case(2)    ! D
          do j=1,5
            do i=1,6
              fo(i)=fo(i)+dmap(i,j)*fi(j)
            end do
          end do
        case(3)    ! F
          do j=1,7
            do i=1,10
              fo(i)=fo(i)+fmap(i,j)*fi(j)
            end do
          end do
        case(4)    ! G
          do j=1,9
            do i=1,15
              fo(i)=fo(i)+gmap(i,j)*fi(j)
            end do
          end do
        case default  ! S,P
          fo(1:9)=fi
          return
      end select

      return
      end

c-----------------------------------------------------------------------
c--- write MO.s (spherical basis functions) to a temporary file.
c-----------------------------------------------------------------------
      subroutine backupmols(imol,ispn,imo0,nmo,nmotot,sumocc,ifspin,
     & ifbeta,iprog,th,ierr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      character*100 tmp
      dimension npure(5),puremo(9),ncart(5),cartmo(15),scal(9)
      data npure/1,3,5,7,9/,ncart/1,3,6,10,15/

c--- obtain scale factor for orca 2.7 (may be suitable for other versions)
c        class                           factor
c   1    s                             * 1.0
c        p
c        d
c        f(0,+1,-1,+2,-2)
c        g(0,+1,-1,+2,-2)
c   2    f(+3,-3)                      * -1.0
c        g(+3,-3,+4,-4)
c--- For low point group symmetries, the default MO factors by ORCA can not
c--- pass AIMALL's examination if there are f, g functions.
      scal=1.d0
      if(iprog.eq.1)scal(6:9)=-1.d0

      rewind(imol)
      rewind(ispn)
      rewind(imo0)

      sumocc=0.d0
      ierr=0
      ifspin=1    ! 0/1: without / with spin
      ifbeta=0    ! 0/1: without / with beta spin
      nmotot=0    ! total number of orbitals
      nmo=0       ! number of occupied orbitals
      ene=0.d0
      occ=0.d0
      Isp=0       ! 0 (unknown), 1 (alpha or alpha+beta), 2 (beta)

200   read(imo0,"(100a)",end=500)tmp
      if(len_trim(tmp).eq.0) goto 200
      call charl2u(tmp,100)
      if(index(tmp,'ENE').ne.0)then
        is=index(tmp,'=')
c       in ACES2-F, there may be " Ene=   ********"
        if(index(tmp(is+1:),'***').eq.0) read(tmp(is+1:),*) ene
      else if(index(tmp,'OCCUP').ne.0)then
        is=index(tmp,'=')
        read(tmp(is+1:),*) occ
        nmotot=nmotot+1
        if(abs(occ).gt.th) nmo=nmo+1
        sumocc=sumocc+occ
      else if(index(tmp,'SPIN').ne.0)then
        Isp = MOspin(tmp)
        ifspin=min(ifspin,Isp)
        ifbeta=max(ifbeta,Isp/2)
      else if(index(tmp,'SYM').ne.0)then
c       do nothing
      else
c       write occ, ene, and spin
        write(imol,"(A7,f20.8,/,A7,f20.8)")' OCCUP=',occ,' ENE=  ',ene
        if(abs(occ).gt.th) write(ispn,"(i2)")Isp
c       dump MO coefficients
        idxmo=0
        do i=1,nbs
          nrd=npure(ibstyp(i)+1)
          nou=ncart(ibstyp(i)+1)
          do j=1,nrd
            if(i.eq.1 .and. j.eq.1)then
              read(tmp,*,err=300)it,puremo(j)
            else
              read(imo0,*,err=300)it,puremo(j)
            end if
            puremo(j)=puremo(j)*scal(j)
            cycle
c           find a star in the MO coefficients!
300         ierr=1
            goto 500
          end do
          call sph2car(ibstyp(i),puremo,cartmo)
          do j=1,nou
            idxmo=idxmo+1
            write(imol,"(i5,1x,d18.10)")idxmo,cartmo(j)
          end do
        end do
        ene=0.d0
        occ=0.d0
        Isp=0
      end if
      goto 200

500   return
      end

c-----------------------------------------------------------------------
c--- write MO.s (Cartesian basis functions) to a temporary file.
c-----------------------------------------------------------------------
      subroutine backupmolc(imol,ispn,imo0,nmo,nmotot,sumocc,ifspin,
     & ifbeta,ngc,th,ierr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp

      rewind(imol)
      rewind(ispn)
      rewind(imo0)

      sumocc=0.d0
      ierr=0
      ifspin=1    ! 0/1: without / with spin
      ifbeta=0    ! 0/1: without / with beta spin
      nmotot=0    ! total number of orbitals
      nmo=0       ! number of occupied orbitals
      ene=0.d0
      occ=0.d0
      Isp=0       ! 0 (unknown), 1 (alpha or alpha+beta), 2 (beta)

200   read(imo0,"(100a)",end=500)tmp
      if(len_trim(tmp).eq.0) goto 200
      call charl2u(tmp,100)
      if(index(tmp,'ENE').ne.0)then
        is=index(tmp,'=')
c       in ACES2-F, there may be " Ene=   ********"
        if(index(tmp(is+1:),'***').eq.0) read(tmp(is+1:),*) ene
      else if(index(tmp,'OCCUP').ne.0)then
        is=index(tmp,'=')
        read(tmp(is+1:),*) occ
        nmotot=nmotot+1
        if(abs(occ).gt.th) nmo=nmo+1
        sumocc=sumocc+occ
      else if(index(tmp,'SPIN').ne.0)then
        Isp = MOspin(tmp)
        ifspin=min(ifspin,Isp)
        ifbeta=max(ifbeta,Isp/2)
      else if(index(tmp,'SYM').ne.0)then
c       do nothing
      else
c       write occ, ene, and spin
        write(imol,"(A7,f20.8,/,A7,f20.8)")' OCCUP=',occ,' ENE=  ',ene
        if(abs(occ).gt.th) write(ispn,"(i2)")Isp
c       dump MO coefficients
        do i=1,ngc
          if(i.gt.1) read(imo0,"(a100)")tmp
c         find a star in the MO coefficients!
          if(index(tmp,'*').ne.0)then
            ierr=1
            goto 500
          end if
          write(imol,"(a)")trim(tmp)
        end do
        ene=0.d0
        occ=0.d0
        Isp=0
      end if
      goto 200

500   return
      end

c-----------------------------------------------------------------------
c--- backup MO, and fill in missing zero coefficients if ishrt=1
c-----------------------------------------------------------------------
      subroutine fill0s(imo0,ncarmo,ishrt)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp

      imod=44
      rewind(imo0)
      rewind(imod)

100   read(imod,"(100a)",end=9999)tmp
      call charl2u(tmp,100)
      if(index(tmp,'[MO]').ne.0)then
        if(ishrt .eq. 0)then
          goto 200
        else
          nc = ncarmo
          goto 400
        end if
      end if
      goto 100

200   read(imod,"(100a)",end=9999)tmp
      if(len_trim(tmp).eq.0) goto 200
      if(index(tmp,'[').ne.0) goto 9999
      write(imo0,"(100a)")trim(tmp)
      goto 200

400   read(imod,"(100a)",end=9990)tmp
      if(len_trim(tmp).eq.0) goto 400
      if(index(tmp,'[').ne.0) goto 9990
      if(index(tmp,'=').ne.0)then
        if(nc .lt. ncarmo .and. nc .gt. 0)then
          do i=nc+1,ncarmo
            write(imo0,"(i5,f16.6)")i,0.d0
          end do
        end if
        nc = 0
        write(imo0,"(100a)")trim(tmp)
        goto 400
      end if

      nc = nc + 1
      read(tmp,*)idx
      if(nc .lt. idx)then
        do i=nc,idx-1
          write(imo0,"(i5,f16.6)")i,0.d0
        end do
        nc = idx
      end if
      write(imo0,"(100a)")trim(tmp)
      goto 400

9990  if(nc .lt. ncarmo .and. nc .gt. 0)then
        do i=nc+1,ncarmo
          write(imo0,"(i5,f16.6)")i,0.d0
        end do
      end if
9999  write(imo0,*)
      return
      end

c-----------------------------------------------------------------------
c--- get the number of contracted basis functions
c-----------------------------------------------------------------------
      subroutine readng(tmp,al,ng)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp
      character*2 al

      read(tmp,*)al,ng

      return
      end

c-----------------------------------------------------------------------
c--- Write basis functions. 'SP' basis functions are saved separately.
c-----------------------------------------------------------------------
      subroutine truncate(tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp
      character*2 al

      imod=44
      itmp=55
      igtoin=56

c---  When there are huge lines to analyze, open/close is not stable.
c---  So I moved open and close on the top of truncate.
c
c      open(itmp,file='temp123456789.tmp',status='new')

      call readng(tmp,al,ng)
      rewind(itmp)

      ng1=ng
      do i=1,ng
        if(al.eq.'SP')then
          read(imod,*)exp,fc1,fc2
        else
          read(imod,*)exp,fc1
          fc2=1.d0
        end if
        if(abs(fc1*fc2).gt.1.d-8)then
          if(al.eq.'SP')then
            write(itmp,"(E20.10,2x,E20.10,2x,E20.10)")exp,fc1,fc2
          else
            write(itmp,"(E20.10,2x,E20.10)")exp,fc1
          end if
        else
          ng1=ng1-1
          cycle
        end if
      end do

      if(al.eq.'SP')then
        write(igtoin,*)"S ",ng1,"1.0"
      else
        write(igtoin,*)al,ng1,"1.0"
      end if

      rewind(itmp)
      do i=1,ng1
        read(itmp,*)exp,fc1
        write(igtoin,"(E20.10,2x,E20.10)")exp,fc1
      end do

c--- SP functions are saved separately
      if(al.eq.'SP')then
        write(igtoin,*)"P ",ng1,"1.0"
        rewind(itmp)
        do i=1,ng1
          read(itmp,*)exp,fc1,fc2
          write(igtoin,"(E20.10,2x,E20.10)")exp,fc2
        end do
      end if

c      close(itmp,status='delete')

      return
      end

c-----------------------------------------------------------------------
c--- back up GTOs
c-----------------------------------------------------------------------
      subroutine backupgto(imod,nat,iprog,ifgto)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp
      character*2 al

      itmp=55
      igtoin=56
      igtold=57
      ispace=0
      ifirst=0
      ifgto=1

      open(itmp,file='temp123456789.tmp')
      open(igtoin,file='igt123456789.tmp')
      open(igtold,file='old123456789.tmp')
c--- step 1: backup original GTO
      rewind(imod)
      rewind(igtoin)

100   read(imod,"(100a)",end=150)tmp
      call charl2u(tmp,100)
      if(index(tmp,'[GTO]').ne.0)then    ! the first several blank lines are skipped
        do while(ifirst.eq.0)
          read(imod,"(100a)",end=500)tmp
          ifirst=len_trim(tmp)
        end do
        goto 201
      end if
      goto 100

150   write(*,*)"### Wrong! [GTO] can not be found!"
      ifgto=0
      close(igtoin,status='delete')
      return

200   read(imod,"(100a)",end=500)tmp
201   call charl2u(tmp,100)
      if(index(tmp,'[').ne.0) then
        if(ispace.eq.0)write(igtoin,"(' E 0')")    ! E = END
        goto 500
      else
        if(len_trim(tmp).gt.0)then
          if(index(tmp,'S').ne.0.or.index(tmp,'P').ne.0.or.
     *       index(tmp,'D').ne.0.or.index(tmp,'F').ne.0.or.
     *       index(tmp,'G').ne.0.or.index(tmp,'H').ne.0)then
            call truncate(tmp)
          else
            write(igtoin,"(a)")trim(tmp)
          end if
          ispace=0
        else
          if(ispace.eq.0)then
            write(igtoin,"(' E 0')")    ! E = END
            ispace=1                    ! the second blank line is skipped
          end if
        end if
      end if
      goto 200

500   continue

c--- step 2: re-normalize GTO and copy it to igtold because the GTO in the
c--- MOLDEN file may be unnormalized
      call bknorm(iprog,ifgto)

c--- setp 3: reorder, and dump igtold to igto
      if(ifgto .eq. 1) call dumpbs(nat,ifgto)

      close(igtoin,status='delete')
      close(igtold,status='delete')
      close(itmp,status='delete')

      return
      end

c-----------------------------------------------------------------------
c--- reorder, and dump igtold to igto
c    NOTE: because of some uncertainties in the MOLDEN format, atoms in
c    {Atoms} and [GTO] must be ordered ascendingly.
c-----------------------------------------------------------------------
      subroutine dumpbs(nat,ierr)
      implicit double precision (a-h,o-z)
      character*100 tmp

      igtold=57
      igto=51
      rewind(igto)

      do i=1,nat
        call locatm(i,ierr)
        if(ierr.eq.0)goto 9999
        write(igto,"(i5,' 0')")i
100     read(igtold,"(100a)",end=200)tmp
        if(tmp(1:1).eq.'&')goto 200
        write(igto,"(a)")trim(tmp)
        goto 100
200     continue
      end do

9999  return
      end

c-----------------------------------------------------------------------
c--- locate atom-i in igtold
c-----------------------------------------------------------------------
      subroutine locatm(i,ierr)
      implicit double precision (a-h,o-z)
      character*100 tmp

      igtold=57
      ierr=0
      rewind(igtold)
100   read(igtold,"(100a)",end=1000)tmp
      if(tmp(1:1).ne.'&')goto 100
      read(tmp(2:100),*)it
      if(it.ne.i)goto 100
      ierr=1
      return

1000  write(*,"(/,' ### Wrong! No basis for atom ',i5,/)")i
      return
      end

c-----------------------------------------------------------------------
c--- renormalize the basis set. it is important for some basis sets (eg.
c---   helium 6-31G)
c-----------------------------------------------------------------------
      subroutine bknorm(iprog,ierr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      character*1 al

      igtold=57
      igtoin=56

      rewind(igtold)
      rewind(igtoin)

      iat=0
100   read(igtoin,*,end=500)ic1
      iat=iat+1
c     check compatibility: because of some uncertainties in the MOLDEN
c     format, the atomic indices must be 1,2,3,4,...
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     It's found that in Molden 5.0, if the ordering of GTO centers is,
c     for example, 3,1,2, then the MO coefficients in [MO] are also in
c     the same order 3,1,2.
c     This means that the atoms in [Atoms] should be reordered according
c     to the ordering in [GTO]. Example:
c
c     < original MOLDEN file >
c
c     [Atoms] Angs
c     F     1    9    ...
c     H     2    1    ...
c     [GTO]
c       2 0
c     ... (basis functions of H)
c       1 0
c     ... (basis functions of F)
c
c     < modified MOLDEN file >
c
c     [Atoms] Angs
c     H     1    1    ...
c     F     2    9    ...
c     [GTO]
c       1 0
c     ... (basis functions of H)
c       2 0
c     ... (basis functions of F)
c
c     However in CFour's MOLDEN, the atomic numbers in [GTO] should be
c     corrected.
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if(iat .ne. ic1)then
        write(*,"(
     &    ' Error: the atoms in [GTO] are not ordered ascendingly.',/,
     &    ' Please correct the MOLDEN file using ReOrdAtm in util by')")
        if(iprog .eq. 2)then
          write(*,"(/,' roa.exe -m 1 < old_molden > new_molden')")
        else
          write(*,"(/,' roa.exe < old_molden > new_molden')")
        end if
        ierr=0
        goto 500
      end if

      write(igtold,"('&',i5,' 0')")ic1
200   read(igtoin,*)al,np
c--- maxpgc is much larger than np
c      if(np.gt.maxpgc)then
c        write(*,*)"Error: too many contracted Gaussian functions!"
c        write(*,*)" NP=",np," MAXPGC=",maxpgc
c        write(*,*)"Please increase MAXPGC and try again."
c        call estop
c      end if
      if(al.eq.'E'.and.np.eq.0)then
        write(igtold,"(1x,a1,1x,i1)")al,np
        goto 100
      else
        write(igtold,"(1x,a1,i4,' 1.0')")al,np
      end if

      do i=1,np
        read(igtoin,*)expgc(i),confc(i)
        cbs=1.d0
c       Orca or PSI4: transform the basis set into input format
        if(iprog.eq.1 .or. iprog.eq.7)cbs=fnorm(expgc(i),al)
        confc(i)=confc(i)/cbs
      end do

c--- For uncontracted basis functions, the contraction coefficient can be
c    renormalized to +1.0 or -1.0, depending on its sign. Do not change the sign!
      call renorm(al,expgc,confc,np)
      do i=1,np
        write(igtold,"(d20.10,2x,d20.10)")expgc(i),confc(i)
      end do
      goto 200

500   continue

      return
      end

c-----------------------------------------------------------------------
c--- calculate the normalization factor for GTO(L)
c-----------------------------------------------------------------------
      function fnorm(ex,al)
      implicit double precision (a-h,o-z)
      character*1 al

      pi=acos(-1.d0)
      pi3=pi**3.d0

c---  unnormalize primitives
c---  Normal^4 = 2^n1 * a^n2 / (pi^3 * nf)
c---  where n1=3+4*L; n2=3+2*L, nf=[(2L-1)!!]^2
      call power(al,n1,n2,nf)
      f = (2.d0**dble(n1)) * (ex**dble(n2)) / (pi3 * dble(nf))
      fnorm=sqrt(sqrt(f))

      return
      end

c-----------------------------------------------------------------------
c--- back up atoms and coordinates
c-----------------------------------------------------------------------
      subroutine backupatm(ifatm)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp

      imod=44
      iatm=50
      ifatm=1

      rewind(imod)
      rewind(iatm)

100   read(imod,"(100a)",end=150)tmp
      call charl2u(tmp,100)
      if(index(tmp,'[ATOMS]').ne.0) then
        if(index(tmp,'ANGS').ne.0)then
          iunit=0
        else if(index(tmp,'AU').ne.0)then
          iunit=1
        else
          iunit=2
        end if
        goto 200
      end if
      goto 100

150   write(*,*)"*** Wrong! [ATOMS] can not be found!"
      ifatm=0
      return

200   write(iatm,"(i1)")iunit
201   read(imod,"(100a)",end=500)tmp
      call charl2u(tmp,100)
      if(index(tmp,'[').ne.0) then
        goto 500
      else
        write(iatm,"(a)")trim(tmp)
      end if
      goto 201

500   continue

      return
      end

c-----------------------------------------------------------------------
c--- count the numbers of Cartesian and Spherical basis functions from
c--- GTO.
c-----------------------------------------------------------------------
      subroutine npgau(Ierr,ncar,nsph,MaxL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
c--- Cartesian NC-/C-GTO; Spherical NC-/C-GTO
      dimension ncar(2),nsph(2)
      character*100 tmp
      character*2 al

      igto=51

      ns=0
      np=0
      nd=0
      nf=0
      ng=0
      nsc=0
      npc=0
      ndc=0
      nfc=0
      ngc=0
      ibs=0
      MaxL=0
      Ierr=0

      rewind(igto)
200   read(igto,"(100a)",end=500)tmp

      if(index(tmp,'S ').ne.0)then
        call readng(tmp,al,npg)
        ns=ns+npg
        nsc=nsc+1
        ibs=ibs+1
        if(ibs.le.maxpgc)ibstyp(ibs)=0
      else if(index(tmp,'P ').ne.0)then
        call readng(tmp,al,npg)
        np=np+npg
        npc=npc+1
        ibs=ibs+1
        if(ibs.le.maxpgc)ibstyp(ibs)=1
      else if(index(tmp,'D ').ne.0)then
        call readng(tmp,al,npg)
        nd=nd+npg
        ndc=ndc+1
        ibs=ibs+1
        if(ibs.le.maxpgc)ibstyp(ibs)=2
      else if(index(tmp,'F ').ne.0)then
        call readng(tmp,al,npg)
        nf=nf+npg
        nfc=nfc+1
        ibs=ibs+1
        if(ibs.le.maxpgc)ibstyp(ibs)=3
      else if(index(tmp,'G ').ne.0)then
        call readng(tmp,al,npg)
        ng=ng+npg
        ngc=ngc+1
        ibs=ibs+1
        if(ibs.le.maxpgc)ibstyp(ibs)=4
      else if(index(tmp,'H ').ne.0)then
        Ierr=1
        goto 600
      end if

      goto 200

500   ncar(1)=ns+np*3+nd*6+nf*10+ng*15
      ncar(2)=nsc+npc*3+ndc*6+nfc*10+ngc*15
      nsph(1)=ns+np*3+nd*5+nf*7+ng*9
      nsph(2)=nsc+npc*3+ndc*5+nfc*7+ngc*9
      nbs=ibs
c      write(*,*)ncar,nsph,nbs

c--- ncar(1)>=nsph(1)
c--- ncar(2)>=nsph(2)>=nbs
c--- so it's enough to check NCar only
      if(ncar(1).gt.maxpg)then
        write(*,"(//,1x,77('-'))")
        write(*,"(' Error: too many primitive Gaussian functions!')")
        write(*,"('  NCar(1) = ',i7,'   MaxPG = ',i7)")ncar(1),maxpg
        write(*,"(' Please increase MaxPG and try again.',/,
     *            1x,77('-'))")
        Ierr=2
      end if
      if(ncar(2).gt.maxpgc)then
        write(*,"(//,1x,77('-'))")
        write(*,"(' Error: too many contracted Gaussian functions!')")
        write(*,"('  NCar(2) = ',i7,'   MaxPGC = ',i7)")ncar(2),maxpgc
        write(*,"(' Please increase MaxPGC and try again.',/,
     *            1x,77('-'))")
        Ierr=2
      end if

c     MaxL
      if(ng.gt.0)then
        MaxL=4
      else if(nf.gt.0)then
        MaxL=3
      else if(nd.gt.0)then
        MaxL=2
      else if(np.gt.0)then
        MaxL=1
      else
        MaxL=0
      end if

600   continue

      return
      end

c-----------------------------------------------------------------------
c--- count the number of atoms.
c-----------------------------------------------------------------------
      subroutine natom(nat,nchar,iunit,ierr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*10 tmp

      iatm=50
      ierr=0

      iat=0
      nchar=0
      rewind(iatm)
      read(iatm,*)iunit

200   read(iatm,*,end=500,err=300)tmp,nat,icha
      iat=iat+1
c     check compatibility: because of some uncertainties in the MOLDEN
c     format, the atomic indices must be 1,2,3,4,...
      if(iat .ne. nat)then
        write(*,"(
     &    ' Error: atoms in [Atoms] are not ordered ascendingly.',/,
     &    ' Please correct the MOLDEN file using ReOrdAtm in util.')")
        ierr=1
        goto 500
      end if
      nchar=nchar+icha
      goto 200

c--- In the geometry optimization of deMon2k, the format is
c--- "atom, x, y, z"
300   write(*,*)"*** The [Atoms] section is wrong!"
      write(*,*)"Please check your MOLDEN file carefully."
      ierr=1

500   continue

      return
      end

c-----------------------------------------------------------------------
c--- tmp --> TMP
c-----------------------------------------------------------------------
      subroutine charl2u(tmp,nc)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*(*) tmp
      character*1 L2U

c      do i=1,nc
      do i=1,len_trim(tmp)
        tmp(i:i)=L2U(tmp(i:i))
      end do

      return
      end

c-----------------------------------------------------------------------
c--- l-->L
c-----------------------------------------------------------------------
      function L2U(letter)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*1 letter,L2U
      if((ichar(letter).ge.97).and.(ichar(letter).le.122))then
        L2U=char(ichar(letter)-32)
      else
        L2U=letter
      endif
      return
      end

c-----------------------------------------------------------------------
c--- length of a string without the first and last spaces.
c-----------------------------------------------------------------------
      function nonspace(string)
      implicit double precision (a-h,o-z)
      character*(*) string
      character*1 space

      space=' '
      length=LEN_TRIM(string)
      if(length.eq.0) then
       i=1
      else
       do i=1,length
         if(string(i:i).ne.space) goto 20
       end do
      endif

20    nonspace=i

      return
      end

c-----------------------------------------------------------------------
c--- lenchar: length of a string without tail spaces.
c-----------------------------------------------------------------------
      function lenchar(string)
      implicit double precision (a-h,o-z)
      character*(*) string
      character*1 space

      space=' '
      i=len(string)

      do 10 while(i.gt.0.and.string(i:i).eq.space)
        i=i-1
10    continue

      lenchar=i

      return
      end

c-----------------------------------------------------------------------
c--- trulen: true length of a string
c--- len1: pointor to the first non-space character
c--- len2: pointor to the last non-space character
c--- length: true length of a string without the initial and tail spaces
c-----------------------------------------------------------------------
      subroutine trulen(cha,len1,len2,length)
      implicit double precision (a-h,o-z)
      character*(*) cha

      len1=nonspace(cha)
      len2=lenchar(cha)
      length=len2-len1+1

      return
      end

c-----------------------------------------------------------------------
c--- renormalize a contracted basis function
c-----------------------------------------------------------------------
      subroutine renorm(al,a,ci,ngauss)
      implicit double precision (a-h,o-z)
      parameter (tol=1.0d-10,maxpgc=10000)
      dimension a(*),ci(*),c(maxpgc)
      character*1 al

      pi=acos(-1.d0)
      pi3=pi**3.d0

c--- ngauss.le.maxpgc has been checked in subroutine bknorm

c--- unnormalize primitives
c--- Normal^4 = 2^n1 * a^n2 / (pi^3 * nf)
c---   n1=3+4*L; n2=3+2*L, nf=[(2L-1)!!]^2
      call power(al,n1,n2,nf)
      fc = (2.d0**dble(n1)) / (pi3 * dble(nf))
      do i = 1,ngauss
        f = fc * (a(i)**dble(n2))
        f = sqrt(sqrt(f))
        c(i) = ci(i)*f
      end do

      fsum = 0.d0
      do i = 1,ngauss
        do j = 1,i
          a2 = (a(i)+a(j))/2.d0
          f = fc * (a2**dble(n2))
          f = sqrt(f)
          f = c(i)*c(j)/f
          if (i .ne. j) f = f*2.d0
          fsum = fsum+f
        end do
      end do

      if (fsum .gt. tol) fsum = 1.d0/sqrt(fsum)
      do i = 1,ngauss
        ci(i) = ci(i) * fsum
      end do

      return
      end

c-----------------------------------------------------------------------
c--- get power(n1,n2,nf) for GTO(L) normalization
c--- n1=3+4*L; n2=3+2*L, nf=[(2L-1)!!]^2
c-----------------------------------------------------------------------
      subroutine power(al,n1,n2,nf)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*1 al

      n1=0
      n2=0
      nf=0
      select case(al)
        case('S')
          n1=3
          n2=3
          nf=1
        case('P')
          n1=7
          n2=5
          nf=1
        case('D')
          n1=11
          n2=7
          nf=9
        case('F')
          n1=15
          n2=9
          nf=225
        case('G')
          n1=19
          n2=11
          nf=11025
      end select

      return
      end

c-----------------------------------------------------------------------
c---  compute scaling factors for MO coefficients
c-----------------------------------------------------------------------
      subroutine moscale(iprog,ncg)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      dimension itypc(maxpgc)
      character*1 al

      igto=51
c     cfour, aces2, or molcas (cart.)
      if(iprog.eq.2 .or. iprog.eq.5 .or. iprog.eq.6)then
        goto 100
c     turbomole
      else if(iprog.eq.3)then
        goto 200
c     mrcc (cart.)
      else if(iprog.eq.8)then
        goto 300
      else
        goto 5000
      end if

100   rewind(igto)
      ip1=0
      ip2=0
c---  Cartesian CGTO types of cfour, aces2, or molcas (cart.)
110   read(igto,*,end=5000)
120   read(igto,*)al,np
      if(al.eq.'E'.and.np.eq.0)goto 110
      do i=1,np
        read(igto,*)
      end do
      select case(al)
        case('S')
          ip1=ip2+1
          ip2=ip2+1
          itypc(ip1:ip2)=1
        case('P')
          ip1=ip2+1
          ip2=ip2+3
          itypc(ip1:ip2)=1
        case('D')
          ip1=ip2+1
          ip2=ip2+6
          itypc(ip1:(ip1+2))=2
          itypc((ip1+3):ip2)=1
        case('F')
          ip1=ip2+1
          ip2=ip2+10
          itypc(ip1:(ip1+2))=4
          itypc((ip1+3):(ip2-1))=2
          itypc(ip2:ip2)=1
        case('G')
          ip1=ip2+1
          ip2=ip2+15
          itypc(ip1:(ip1+2))=5
          itypc((ip1+3):(ip1+8))=4
          itypc((ip1+9):(ip1+11))=3
          itypc((ip2-2):ip2)=2
      end select
      goto 120

200   rewind(igto)
      ip1=0
      ip2=0
c---  Cartesian CGTO types of turbomole
210   read(igto,*,end=5000)
220   read(igto,*)al,np
      if(al.eq.'E'.and.np.eq.0)goto 210
      do i=1,np
        read(igto,*)
      end do
      select case(al)
        case('S')
          ip1=ip2+1
          ip2=ip2+1
          itypc(ip1:ip2)=1
        case('P')
          ip1=ip2+1
          ip2=ip2+3
          itypc(ip1:ip2)=1
        case('D')
          ip1=ip2+1
          ip2=ip2+6
          itypc(ip1:ip2)=2
        case('F')
          ip1=ip2+1
          ip2=ip2+10
          itypc(ip1:ip2)=3
        case('G')
          ip1=ip2+1
          ip2=ip2+15
          itypc(ip1:ip2)=4
      end select
      goto 220

300   rewind(igto)
      ip1=0
      ip2=0
c---  Cartesian CGTO types of mrcc
310   read(igto,*,end=5000)
320   read(igto,*)al,np
      if(al.eq.'E'.and.np.eq.0)goto 310
      do i=1,np
        read(igto,*)
      end do
      select case(al)
        case('S')
          ip1=ip2+1
          ip2=ip2+1
          itypc(ip1:ip2)=1
        case('P')
          ip1=ip2+1
          ip2=ip2+3
          itypc(ip1:ip2)=1
        case('D')
          ip1=ip2+1
          ip2=ip2+6
          itypc(ip1:(ip1+2))=1
          itypc((ip1+3):ip2)=2
        case('F')
          ip1=ip2+1
          ip2=ip2+10
          itypc(ip1:(ip1+2))=1
          itypc((ip1+3):(ip2-1))=3
          itypc(ip2:ip2)=4
        case('G')
          ip1=ip2+1
          ip2=ip2+15
          itypc(ip1:(ip1+2))=1
          itypc((ip1+3):(ip1+8))=5
          itypc((ip1+9):(ip1+11))=6
          itypc((ip2-2):ip2)=7
      end select
      goto 320

5000  continue
c      write(99,*)ip2
c      write(99,"(i4)")itypc(1:ip2)

      if(iprog.eq.2 .or. iprog.eq.5 .or. iprog.eq.6)then
c---    cfour, aces2 (Cart.), or molcas (Cart.)
        do i=1,ncg
          scalmo(i)=obscalc4(itypc(i))
        end do
      else if(iprog.eq.3)then
c---    turbomole (Cart.)
        do i=1,ncg
          scalmo(i)=obscaltm(itypc(i))
        end do
      else if(iprog.eq.8)then
c---    mrcc (Cart.)
        do i=1,ncg
          scalmo(i)=obscalmr(itypc(i))
        end do
      else
c---    default; orca (spher.); jaguar
        do i=1,ncg
          scalmo(i)=1.d0
        end do
      end if

      return
      end

c-----------------------------------------------------------------------
c---  obtain scale factor for mrcc (Cart.)
c     class                                factor
c     1    s                             * 1.0
c          p(x,y,z)                      * 1.0
c          d(xx,yy,zz)
c          f(xxx,yyy,zzz)
c          g(x4,y4,z4)
c     2    d(xy,xz,yz)                   * 1/sqrt(3)
c     3    f(xyy,xzz,yxx,yzz,zxx,zyy)    * 1/sqrt(5)
c     4    f(xyz)                        * 1/sqrt(15)
c     5    g(x3y,x3z,y3x,y3z,z3x,z3y)    * 1/sqrt(7)
c     6    g(x2y2,x2z2,y2z2)             * sqrt(3/35)
c     7    g(x2yz,y2xz,z2xy)             * 1/sqrt(35)
c-----------------------------------------------------------------------
      function obscalmr(iclass)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      select case(iclass)
        case(1)
          a=1.d0
        case(2)
          a=sqrt(1.d0/3.d0)
        case(3)
          a=sqrt(1.d0/5.d0)
        case(4)
          a=sqrt(1.d0/15.d0)
        case(5)
          a=sqrt(1.d0/7.d0)
        case(6)
          a=sqrt(3.d0/35.d0)
        case(7)
          a=sqrt(1.d0/35.d0)
      end select

      obscalmr=a

      return
      end

c-----------------------------------------------------------------------
c---  obtain scale factor for turbomole
c     class                                factor
c     1    s                             * 1.0
c          p
c     2    d                             * sqrt(3)
c     3    f                             * sqrt(15)
c     4    g                             * sqrt(105)
c-----------------------------------------------------------------------
      function obscaltm(iclass)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      select case(iclass)
        case(1)
          a=1.d0
        case(2)
          a=sqrt(3.d0)
        case(3)
          a=sqrt(15.d0)
        case(4)
          a=sqrt(105.d0)
      end select

      obscaltm=a

      return
      end

c-----------------------------------------------------------------------
c---  obtain scale factor for cfour
c     class                                factor
c     1    s                             * 1.0
c          p(x,y,z)
c          d(xy,xz,yz)
c          f(xyz)
c     2    d(xx,yy,zz)                   * sqrt(3)
c          f(xyy,xzz,yxx,yzz,zxx,zyy)
c          g(x2yz,y2xz,z2xy)
c     3    g(x2y2,x2z2,y2z2)             * 3.0
c     4    f(xxx,yyy,zzz)                * sqrt(15)
c          g(x3y,x3z,y3x,y3z,z3x,z3y)
c     5    g(x4,y4,z4)                   * sqrt(105)
c-----------------------------------------------------------------------
      function obscalc4(iclass)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      select case(iclass)
        case(1)
          a=1.d0
        case(2)
          a=sqrt(3.d0)
        case(3)
          a=3.d0
        case(4)
          a=sqrt(15.d0)
        case(5)
          a=sqrt(105.d0)
      end select

      obscalc4=a

      return
      end

c-----------------------------------------------------------------------
c---  calculate the overlap matrix element
c---  s = <itype1, a1, r1 | itype2, a2, r2>
c---    = <l1, m1, n1, a1, r1 | l2, m2, n2, a2, r2>
c-----------------------------------------------------------------------
      subroutine overlap(s,itype1,a1,r1,itype2,a2,r2,MaxL,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension r1(3),r2(3),p(3),dgn(0:MaxL),pan(0:MaxL,3),pbn(0:MaxL,3)
      data one/1.d0/
      save one

      pi=acos(-one)

c--- production of the normalization factors
      s=fnorm_lmn(a1,itype1)*fnorm_lmn(a2,itype2)

c---  gamma = as + bs and (2*gamma)^-n
      g=a1+a2
      dg=g+g
      dgn(0)=one
      do i=1,MaxL
        dgn(i)=dgn(i-1)/dg
      end do

      tmp1=dist(r1,r2)
      s=s*exp(-a1*a2*tmp1*tmp1/g)
      tmp1=sqrt(pi/g)
      s=s*tmp1*tmp1*tmp1

c---  P point
      p(1)=(a1*r1(1)+a2*r2(1))/g
      p(2)=(a1*r1(2)+a2*r2(2))/g
      p(3)=(a1*r1(3)+a2*r2(3))/g

c     pa^n and pb^n
      do j=1,3
        pan(0,j)=one
        pbn(0,j)=one
      end do
      if(MaxL .gt. 0)then
        do j=1,3
          pan(1,j)=p(j)-r1(j)
          pbn(1,j)=p(j)-r2(j)
        end do
        do i=2,MaxL
          do j=1,3
            pan(i,j)=pan(i-1,j)*pan(1,j)
            pbn(i,j)=pbn(i-1,j)*pbn(1,j)
          end do
        end do
      end if

      call pattwf(itype1,l1,m1,n1,info)
        if(info.ne.0) goto 9000
      call pattwf(itype2,l2,m2,n2,info)
        if(info.ne.0) goto 9000

      call integ(sx,MaxL,l1,l2,dgn,pan(0,1),pbn(0,1))
      call integ(sy,MaxL,m1,m2,dgn,pan(0,2),pbn(0,2))
      call integ(sz,MaxL,n1,n2,dgn,pan(0,3),pbn(0,3))
      s=s*sx*sy*sz

9000  return
      end

c-----------------------------------------------------------------------
c---  calculate the integral Ix, Iy, or Iz
c---    (l1+l2)/2
c---  I = sum [fcoef * (2i-1)!! / (2g)^i]
c---      i=0
c-----------------------------------------------------------------------
      subroutine integ(s,MaxL,l1,l2,dgn,pan,pbn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c     Tlm1ff = (2N -1)!!, N=0~5; (2g)^-i; pa^n; pb^n
      dimension Tlm1ff(0:5),dgn(0:MaxL),pan(0:MaxL),pbn(0:MaxL)
      data Tlm1ff/1.D0, 1.D0, 3.D0, 15.D0, 105.D0, 945.D0/
      save Tlm1ff

      s=0.d0
      do i=0,(l1+l2)/2
        call fcoef(tmp,MaxL,i+i,l1,l2,pan,pbn)
        tmp=tmp*Tlm1ff(i)*dgn(i)
        s=s+tmp
      end do

      return
      end

c-----------------------------------------------------------------------
c--- calculate the coefficients
c---           l1   l2
c--- fcoef =  sum  sum [clm(l1,k1) * clm(l2,k2) * a^(l1-k1) * b^(l2-k2)]
c---         k1=0 k2=0
c---          k1+k2=i
c-----------------------------------------------------------------------
      subroutine fcoef(fc,MaxL,i,l1,l2,pan,pbn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension pan(0:MaxL),pbn(0:MaxL)

      fc=0.d0
      do k1=0,l1
        k2=i-k1
        if(k2.lt.0 .or. k2.gt.l2) cycle
        fc = fc + pan(l1-k1) * pbn(l2-k2) * clm(l1,k1) * clm(l2,k2)
      end do

      return
      end

c-----------------------------------------------------------------------
c---  clm = l! / (m! * (l-m)!)
c-----------------------------------------------------------------------
      function clm(l,m)
      implicit real*8(a-h,o-z)
      dimension factorial(0:5)
      data factorial/1.D0,1.D0,2.D0,6.D0,24.D0,120.D0/
      save factorial

      clm=factorial(l)/(factorial(m)*factorial(l-m))

      return
      end

cc-----------------------------------------------------------------------
cc---  n!, n=0~5
cc-----------------------------------------------------------------------
c      function factorial(N)
c      implicit real*8(a-h,o-z)
c
c      select case(N)
c        case(0:1)
c          factorial = 1.D0
c        case(2)
c          factorial = 2.D0
c        case(3)
c          factorial = 6.D0
c        case(4)
c          factorial = 24.D0
c        case(5)
c          factorial = 120.D0
c      end select
c
c      return
c      end
c
cc-----------------------------------------------------------------------
cc---  Tlm1ff = (2N -1)!!, N=0~5
cc-----------------------------------------------------------------------
c      function Tlm1ff(N)
c      implicit real*8(a-h,o-z)
c
c      select case(N)
c        case(0:1)
c          Tlm1ff = 1.D0
c        case(2)
c          Tlm1ff = 3.D0
c        case(3)
c          Tlm1ff = 15.D0
c        case(4)
c          Tlm1ff = 105.D0
c        case(5)
c          Tlm1ff = 945.D0
c      end select
c
c      return
c      end
c
c-----------------------------------------------------------------------
c--- distance between two points
c-----------------------------------------------------------------------
      function dist(p1,p2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension p1(3),p2(3)

      dist=0.d0
      do i=1,3
        dist=dist+(p1(i)-p2(i))*(p1(i)-p2(i))
      end do
      dist=sqrt(dist)

      return
      end

c-----------------------------------------------------------------------
c--- vout = c * vin
c-----------------------------------------------------------------------
      subroutine ascale(N,c,vin,vout)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension vin(*),vout(*)

      do i=1,N
        vout(i)=c*vin(i)
      end do

      return
      end

c-----------------------------------------------------------------------
c---  Routine to clear N elements in array A.
c-----------------------------------------------------------------------
      Subroutine AClear(N,A)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(Zero=0.0d0)
      Dimension A(*)

      Do I = 1,N
        A(I) = Zero
      end do

      Return
      End

c-----------------------------------------------------------------------
c--- Obtain the xyz pattern for a given Cartesian type number. It is
c--- used in MOLDEN.
c--- Note: the ordering 14-19 of F functions is different from the one
c--- in subroutine pattwf.
c--- 1  S     | 11 FXXX  | 21 GXXXX | 31 GXXZZ | 
c--- 2  PX    | 12 FYYY  | 22 GYYYY | 32 GYYZZ | 
c--- 3  PY    | 13 FZZZ  | 23 GZZZZ | 33 GXXYZ | 
c--- 4  PZ    | 14 FXYY  | 24 GXXXY | 34 GXYYZ | 
c--- 5  DXX   | 15 FXXY  | 25 GXXXZ | 35 GXYZZ | 
c--- 6  DYY   | 16 FXXZ  | 26 GXYYY |
c--- 7  DZZ   | 17 FXZZ  | 27 GYYYZ |
c--- 8  DXY   | 18 FYZZ  | 28 GXZZZ |
c--- 9  DXZ   | 19 FYYZ  | 29 GYZZZ |
c--- 10 DYZ   | 20 FXYZ  | 30 GXXYY |
c---
c--- Ordering of G functions in Gaussian. For debug only.
c--- 21 GZZZZ | 31 GXXYZ | 
c--- 22 GYZZZ | 32 GXXYY | 
c--- 23 GYYZZ | 33 GXXXZ | 
c--- 24 GYYYZ | 34 GXXXY | 
c--- 25 GYYYY | 35 GXXXX | 
c--- 26 GXZZZ |
c--- 27 GXYZZ |
c--- 28 GXYYZ |
c--- 29 GXYYY |
c--- 30 GXXZZ |
c-----------------------------------------------------------------------
      subroutine pattml(itype,l,m,n,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension PATDAT(3,35)
      data PATDAT/
c              1          2          3          4          5
     &   0, 0, 0,   1, 0, 0,   0, 1, 0,   0, 0, 1,   2, 0, 0,
c              6          7          8          9         10
     &   0, 2, 0,   0, 0, 2,   1, 1, 0,   1, 0, 1,   0, 1, 1,
c             11         12         13         14         15
     &   3, 0, 0,   0, 3, 0,   0, 0, 3,   1, 2, 0,   2, 1, 0,
c             16         17         18         19         20
     &   2, 0, 1,   1, 0, 2,   0, 1, 2,   0, 2, 1,   1, 1, 1,
c             21         22         23         24         25
     &   4, 0, 0,   0, 4, 0,   0, 0, 4,   3, 1, 0,   3, 0, 1,
c             26         27         28         29         30
     &   1, 3, 0,   0, 3, 1,   1, 0, 3,   0, 1, 3,   2, 2, 0,
c             31         32         33         34         35
     &   2, 0, 2,   0, 2, 2,   2, 1, 1,   1, 2, 1,   1, 1, 2/
cc<<< Gaussian (see also function fnorm_lmn)
cc             21         22         23         24         25
c     &   0, 0, 4,   0, 1, 3,   0, 2, 2,   0, 3, 1,   0, 4, 0,
cc             26         27         28         29         30
c     &   1, 0, 3,   1, 1, 2,   1, 2, 1,   1, 3, 0,   2, 0, 2,
cc             31         32         33         34         35
c     &   2, 1, 1,   2, 2, 0,   3, 0, 1,   3, 1, 0,   4, 0, 0/
cc>>>
      save PATDAT

      info = 0
      if(itype .lt. 1 .or. itype .gt. 35)then
        info = 1
        write(*,"(/,' ### Wrong!',
     *  ' The Cartesian type number is out of range:',i3)")itype
        return
      end if

      l=PATDAT(1,itype)
      m=PATDAT(2,itype)
      n=PATDAT(3,itype)

      return
      end

c-----------------------------------------------------------------------
c--- Obtain the xyz pattern for a given Cartesian type number. It is
c--- used in WFN and WFX.
c--- 1  S     | 11 FXXX  | 21 GXXXX | 31 GXXZZ | 
c--- 2  PX    | 12 FYYY  | 22 GYYYY | 32 GYYZZ | 
c--- 3  PY    | 13 FZZZ  | 23 GZZZZ | 33 GXXYZ | 
c--- 4  PZ    | 14 FXXY  | 24 GXXXY | 34 GXYYZ | 
c--- 5  DXX   | 15 FXXZ  | 25 GXXXZ | 35 GXYZZ | 
c--- 6  DYY   | 16 FYYZ  | 26 GXYYY | 
c--- 7  DZZ   | 17 FXYY  | 27 GYYYZ | 
c--- 8  DXY   | 18 FXZZ  | 28 GXZZZ | 
c--- 9  DXZ   | 19 FYZZ  | 29 GYZZZ | 
c--- 10 DYZ   | 20 FXYZ  | 30 GXXYY |
c-----------------------------------------------------------------------
      subroutine pattwf(itype,l,m,n,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension PATDAT(3,35)
      data PATDAT/
c              1          2          3          4          5
     &   0, 0, 0,   1, 0, 0,   0, 1, 0,   0, 0, 1,   2, 0, 0,
c              6          7          8          9         10
     &   0, 2, 0,   0, 0, 2,   1, 1, 0,   1, 0, 1,   0, 1, 1,
c             11         12         13         14         15
     &   3, 0, 0,   0, 3, 0,   0, 0, 3,   2, 1, 0,   2, 0, 1,
c             16         17         18         19         20
     &   0, 2, 1,   1, 2, 0,   1, 0, 2,   0, 1, 2,   1, 1, 1,
c             21         22         23         24         25
     &   4, 0, 0,   0, 4, 0,   0, 0, 4,   3, 1, 0,   3, 0, 1,
c             26         27         28         29         30
     &   1, 3, 0,   0, 3, 1,   1, 0, 3,   0, 1, 3,   2, 2, 0,
c             31         32         33         34         35
     &   2, 0, 2,   0, 2, 2,   2, 1, 1,   1, 2, 1,   1, 1, 2/
      save PATDAT

      info = 0
      if(itype .lt. 1 .or. itype .gt. 35)then
        info = 1
        write(*,"(/,' ### Wrong!',
     *  ' The Cartesian type number is out of range:',i3)")itype
        return
      end if

      l=PATDAT(1,itype)
      m=PATDAT(2,itype)
      n=PATDAT(3,itype)

      return
      end

c-----------------------------------------------------------------------
c---  B(*) = A(*)
c-----------------------------------------------------------------------
      Subroutine ACopy(N,A,B)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      Dimension A(*),B(*)

      Do I = 1,N
        B(I) = A(I)
      end do

      Return
      End

c-----------------------------------------------------------------------
c     This subroutine is taken from BLAS.
c     Reference BLAS level1 routine (version 3.4.0) --
c     Reference BLAS is a software package provided by Univ. of Tennessee,
c     Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.
c     November 2011
c-----------------------------------------------------------------------
      SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
c
c     .. Scalar Arguments ..
      DOUBLE PRECISION ALPHA,BETA
      INTEGER K,LDA,LDB,LDC,M,N
      CHARACTER TRANSA,TRANSB
c     ..
c     .. Array Arguments ..
      DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)
c     ..
c     .. Intrinsic Functions ..
      INTRINSIC MAX
c     ..
c     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I,INFO,J,L,NCOLA,NROWA,NROWB
      LOGICAL NOTA,NOTB
c     ..
c     .. Parameters ..
      DOUBLE PRECISION ONE,ZERO
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
c     ..
c
c     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
c     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows
c     and  columns of  A  and the  number of  rows  of  B  respectively.
c
      NOTA = TRANSA .eq. 'N'
      NOTB = TRANSB .eq. 'N'
      IF (NOTA) THEN
          NROWA = M
          NCOLA = K
      ELSE
          NROWA = K
          NCOLA = M
      END IF
      IF (NOTB) THEN
          NROWB = K
      ELSE
          NROWB = N
      END IF
c
c     Test the input parameters.
c
      INFO = 0
      IF ((.NOT.NOTA) .AND. (.NOT.(TRANSA .eq. 'C')) .AND.
     +    (.NOT.(TRANSA .eq. 'T'))) THEN
          INFO = 1
      ELSE IF ((.NOT.NOTB) .AND. (.NOT.(TRANSB .eq. 'C')) .AND.
     +         (.NOT.(TRANSB .eq. 'T'))) THEN
          INFO = 2
      ELSE IF (M.LT.0) THEN
          INFO = 3
      ELSE IF (N.LT.0) THEN
          INFO = 4
      ELSE IF (K.LT.0) THEN
          INFO = 5
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN
          INFO = 8
      ELSE IF (LDB.LT.MAX(1,NROWB)) THEN
          INFO = 10
      ELSE IF (LDC.LT.MAX(1,M)) THEN
          INFO = 13
      END IF
      IF (INFO.NE.0) THEN
          WRITE( *, FMT = 9999 ) INFO
          call estop
      END IF
c
c     Quick return if possible.
c
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.
     +    (((ALPHA.EQ.ZERO).OR. (K.EQ.0)).AND. (BETA.EQ.ONE))) RETURN
c
c     And if  alpha.eq.zero.
c
      IF (ALPHA.EQ.ZERO) THEN
          IF (BETA.EQ.ZERO) THEN
              DO 20 J = 1,N
                  DO 10 I = 1,M
                      C(I,J) = ZERO
   10             CONTINUE
   20         CONTINUE
          ELSE
              DO 40 J = 1,N
                  DO 30 I = 1,M
                      C(I,J) = BETA*C(I,J)
   30             CONTINUE
   40         CONTINUE
          END IF
          RETURN
      END IF
c
c     Start the operations.
c
      IF (NOTB) THEN
          IF (NOTA) THEN
c
c           Form  C := alpha*A*B + beta*C.
c
              DO 90 J = 1,N
                  IF (BETA.EQ.ZERO) THEN
                      DO 50 I = 1,M
                          C(I,J) = ZERO
   50                 CONTINUE
                  ELSE IF (BETA.NE.ONE) THEN
                      DO 60 I = 1,M
                          C(I,J) = BETA*C(I,J)
   60                 CONTINUE
                  END IF
                  DO 80 L = 1,K
                      IF (B(L,J).NE.ZERO) THEN
                          TEMP = ALPHA*B(L,J)
                          DO 70 I = 1,M
                              C(I,J) = C(I,J) + TEMP*A(I,L)
   70                     CONTINUE
                      END IF
   80             CONTINUE
   90         CONTINUE
          ELSE
c
c           Form  C := alpha*A**T*B + beta*C
c
              DO 120 J = 1,N
                  DO 110 I = 1,M
                      TEMP = ZERO
                      DO 100 L = 1,K
                          TEMP = TEMP + A(L,I)*B(L,J)
  100                 CONTINUE
                      IF (BETA.EQ.ZERO) THEN
                          C(I,J) = ALPHA*TEMP
                      ELSE
                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)
                      END IF
  110             CONTINUE
  120         CONTINUE
          END IF
      ELSE
          IF (NOTA) THEN
c
c           Form  C := alpha*A*B**T + beta*C
c
              DO 170 J = 1,N
                  IF (BETA.EQ.ZERO) THEN
                      DO 130 I = 1,M
                          C(I,J) = ZERO
  130                 CONTINUE
                  ELSE IF (BETA.NE.ONE) THEN
                      DO 140 I = 1,M
                          C(I,J) = BETA*C(I,J)
  140                 CONTINUE
                  END IF
                  DO 160 L = 1,K
                      IF (B(J,L).NE.ZERO) THEN
                          TEMP = ALPHA*B(J,L)
                          DO 150 I = 1,M
                              C(I,J) = C(I,J) + TEMP*A(I,L)
  150                     CONTINUE
                      END IF
  160             CONTINUE
  170         CONTINUE
          ELSE
c
c           Form  C := alpha*A**T*B**T + beta*C
c
              DO 200 J = 1,N
                  DO 190 I = 1,M
                      TEMP = ZERO
                      DO 180 L = 1,K
                          TEMP = TEMP + A(L,I)*B(J,L)
  180                 CONTINUE
                      IF (BETA.EQ.ZERO) THEN
                          C(I,J) = ALPHA*TEMP
                      ELSE
                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)
                      END IF
  190             CONTINUE
  200         CONTINUE
          END IF
      END IF
c
      RETURN
c
c     End of DGEMM .
 9999 FORMAT( ' ** On entry to DGEMM parameter number ', I2, ' had ',
     $      'an illegal value' )
c
      END

c-----------------------------------------------------------------------
c---  spin of MO:
c     0: unknown
c     1: Alpha, or Alpha and Beta
c     2: Beta
c     NOTE: tmp must be in upper case and contains 'SPIN'
c-----------------------------------------------------------------------
      function MOspin(tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp

      if(index(tmp,'ALPHA').ne.0)then
        MOspin=1
      else if(index(tmp,'BETA').ne.0)then
        MOspin=2
      else
        MOspin=0
      end if

      return
      end

c-----------------------------------------------------------------------
