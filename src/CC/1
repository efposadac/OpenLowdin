!!******************************************************************************
!!
!!		HERE WE GO !!
!!
!!******************************************************************************

module CoupledCluster_
  use Exception_
  use Matrix_
  use Vector_
  use Coupled_
  use ReadTransformedIntegrals_
  use MolecularSystem_
  use String_
  use IndexMap_
  implicit none

  !>
  !! @brief Coupled Interaction Module, works in spin orbitals
  !!
  !! @author Alejandro
  !!
  !! <b> Creation data : </b> 2015
  !!
  !! <b> History change: </b>
  !!
  !!
  !<
  type, public :: CoupledCluster
     logical :: isInstanced
     integer :: numberOfSpecies
     type(matrix) :: hamiltonianMatrix
!     integer :: numberOfCouplings
     type(vector) :: numberOfOccupiedOrbitals
     type(vector) :: numberOfOrbitals
     type(Vector) :: energyCorrectionOfSecondOrder
     type(vector) :: eigenvalues
     type(vector) :: lambda !!Number of particles per orbital, module only works for 1 or 2 particles per orbital
     real(8) :: secondOrderCorrection
     real(8) :: coupledClusterSDCorrection
     type(matrix), allocatable :: fourCenterIntegrals(:,:)
     type(matrix), allocatable :: twoCenterIntegrals(:)
!     type(coupled), allocatable :: couplings(:)
     real(8) :: totalEnergy

     character(20) :: level

  end type CoupledCluster

  type, public :: HartreeFock
        real(8) :: totalEnergy
        real(8) :: puntualInteractionEnergy
        type(matrix) :: coefficientsofcombination 
        type(matrix) :: HcoreMatrix 
  end type HartreeFock
  
  type(CoupledCluster) :: CoupledCluster_instance
  type(HartreeFock) :: HartreeFock_instance

  public :: &
       CoupledCluster_constructor, &
       CoupledCluster_destructor, &
!       CoupledCluster_taus, &
!       CoupledCluster_getTotalEnergy, &
       CoupledCluster_run, &
       CoupledCluster_show

  private		
contains


  !>
  !! @brief Constructor por omision
  !!
  !! @param this
  !<
  subroutine CoupledCluster_constructor(level)
    implicit none
    character(*) :: level

!    integer :: numberOfSpecies
!    integer :: i,j,m,n,p,q,c
!    integer :: isLambdaEqual1
!    type(vector) :: order
!    type(vector) :: occupiedCode
!    type(vector) :: unoccupiedCode
!    real(8) :: totalEnergy
!
!    character(50) :: wfnFile
!    integer :: wfnUnit
!    character(50) :: nameOfSpecie
!    integer :: numberOfContractions
!    character(50) :: arguments(2)
!
!    wfnFile = "lowdin.wfn"
!    wfnUnit = 20
!
!    !! Open file for wavefunction
!    open(unit=wfnUnit, file=trim(wfnFile), status="old", form="unformatted")
!
!    !! Load results...
!    call Vector_getFromFile(unit=wfnUnit, binary=.true., value=HartreeFock_instance%totalEnergy, &
!         arguments=["TOTALENERGY"])
!    call Vector_getFromFile(unit=wfnUnit, binary=.true., value=HartreeFock_instance%puntualInteractionEnergy, &
!         arguments=["PUNTUALINTERACTIONENERGY"])
!
!    numberOfSpecies = MolecularSystem_getNumberOfQuantumSpecies()
!    numberOfContractions = MolecularSystem_getTotalNumberOfContractions(i)
!
!    do i=1, numberOfSpecies
!        nameOfSpecie= trim(  MolecularSystem_getNameOfSpecie( i ) )
!        numberOfContractions = MolecularSystem_getTotalNumberOfContractions( i )
!
!        arguments(2) = nameOfSpecie
!        arguments(1) = "HCORE"
!        HartreeFock_instance%HcoreMatrix  = &
!                  Matrix_getFromFile(unit=wfnUnit, rows= int(numberOfContractions,4), &
!                  columns= int(numberOfContractions,4), binary=.true., arguments=arguments(1:2))
!
!        arguments(1) = "COEFFICIENTS"
!        HartreeFock_instance%coefficientsofcombination = &
!                  Matrix_getFromFile(unit=wfnUnit, rows= int(numberOfContractions,4), &
!                  columns= int(numberOfContractions,4), binary=.true., arguments=arguments(1:2))
!
!!         arguments(1) = "ORBITALS"
!!         call Vector_getFromFile( elementsNum = numberOfContractions, &
!!              unit = wfnUnit, binary = .true., arguments = arguments(1:2), &
!!              output = eigenValues )
!
!
!
!    end do
!
    CoupledCluster_instance%isInstanced=.true.
    CoupledCluster_instance%level=level
! Not necessary... maybe    
!    CoupledCluster_instance%numberOfCouplings=0

!    call Vector_constructor (CoupledCluster_instance%numberOfOccupiedOrbitals, numberOfSpecies)
!    call Vector_constructor (CoupledCluster_instance%numberOfOrbitals, numberOfSpecies)
!    call Vector_constructor (CoupledCluster_instance%lambda, numberOfSpecies)

!    do i=1, numberOfSpecies
       !! We are working in spin orbitals not in spatial orbitals!
!       CoupledCluster_instance%lambda%values(i) = MolecularSystem_getLambda( i )
!       CoupledCluster_instance%numberOfOccupiedOrbitals%values(i)=MolecularSystem_getOcupationNumber( i )* CoupledCluster_instance%lambda%values(i)
!       CoupledCluster_instance%numberOfOrbitals%values(i)=MolecularSystem_getTotalNumberOfContractions( i )* CoupledCluster_instance%lambda%values(i)
       !!Uneven occupation number = alpha
       !!Even occupation number = beta     
!    end do

!    close(wfnUnit)

  end subroutine CoupledCluster_constructor


  !>
  !! @brief Destructor por omision
  !!
  !! @param this
  !<
  subroutine CoupledCluster_destructor()
    implicit none

    CoupledCluster_instance%isInstanced=.false.

  end subroutine CoupledCluster_destructor

  !>
  !! @brief Muestra informacion del objeto
  !!
  !! @param this 
  !<
  subroutine CoupledCluster_show()
    implicit none
    type(CoupledCluster) :: this
    integer :: i
    integer :: m
 
    if ( CoupledCluster_instance%isInstanced ) then

       print *,""
       print *," POST HARTREE-FOCK CALCULATION"
       print *," COUPLED CLUSTER THEORY:"
       print *,"=============================="
       print *,""
       write (6,"(T10,A30, A5)") "LEVEL = ", CoupledCluster_instance%level
!       write (6,"(T10,A30, I10)") "NUMBER OF COUPLINGS = ", CoupledCluster_instance%numberOfCouplings
       write (6,"(T10,A30, F20.12)") "HF ENERGY = ", HartreeFock_instance%totalEnergy
       write (6,"(T10,A30, F20.12)") "MP2 CORR. ENERGY = ", CoupledCluster_instance%secondOrderCorrection
       write (6,"(T10,A30, F20.12)") "CCSD CORR. ENERGY = ", CoupledCluster_instance%coupledClusterSDCorrection
       write (6,"(T10,A30, F20.12)") "============================================================"
       write (6,"(T10,A30, F20.12)") "Total Energy (HF+CCSD) = ", HartreeFock_instance%totalEnergy+CoupledCluster_instance%coupledClusterSDCorrection
!       write (6,"(T10,A30, F20.12)") "CORRELATION ENERGY = ", CoupledCluster_instance%eigenvalues%values(1) - &
!                HartreeFock_instance%totalEnergy

!        do i=1, CoupledCluster_instance%numberOfCouplings
!           call Coupled_show (CoupledCluster_instance%couplings(i))
!        end do

    else 

    end if

  end subroutine CoupledCluster_show

  !>
  !! @brief Muestra informacion del objeto
  !!
  !! @param this 
  !<
  subroutine CoupledCluster_run()
    implicit none 
    integer :: m
    real(8), allocatable :: eigenValues(:) 

    select case ( trim(CoupledCluster_instance%level) )

    case ( "CCSD" )

       print *, ""
       print *, ""
       print *, "==============================================="
       print *, "|            BEGIN CCSD CALCULATION           |"
       print *, "-----------------------------------------------"
       print *, ""

	print *, "  Iteration of intermediates"
	call CoupledCluster_iterateIntermediates()

!        call CoupledCluster_getTransformedIntegrals()

!        print *, "  Building hamiltonian"
!        call CoupledCluster_buildHamiltonianMatrix()

!       call Vector_constructor ( CoupledCluster_instance%eigenvalues, CoupledCluster_instance%numberOfCouplings)

!       print *, "  Diagonalizing hamiltonian"
!       call Matrix_eigen_select (CoupledCluster_instance%hamiltonianMatrix, CoupledCluster_instance%eigenvalues, &
!		1, 1, & !! Only the first 
!		flags = SYMMETRIC, dm = CoupledCluster_instance%numberOfCouplings )

!!       call diagonalize_matrix (CoupledCluster_instance%hamiltonianMatrix%values, CoupledCluster_instance%eigenvalues%values, CoupledCluster_instance%numberOfCouplings)

!!      print *, "hamiltonianMatrix"
!!        call Matrix_show (CoupledCluster_instance%hamiltonianMatrix)
!!       call Vector_show( CoupledCluster_instance%eigenvalues)
       
       print *,""
       print *, "-----------------------------------------------"
       print *, "|              END CCSD CALCULATION           |"
       print *, "==============================================="
       print *, ""

    case default

       call CoupledCluster_exception( ERROR, "Coupled interactor constructor", "Correction level not implemented")

    end select


  end subroutine CoupledCluster_run

 !>
  !! @brief Calculation of the intermediates
  !!
  !<
 subroutine CoupledCluster_iterateIntermediates()
   implicit none

   integer :: numberOfSpecies
   integer :: a,b,c,d
   integer :: i,j,k,l,p,q,r,s,h
   integer(8) :: x,y,z,auxIndex,auxIndex2
   integer :: e,f,m,n
   integer :: speciesID
   integer :: otherSpecieID
   character(10) :: nameOfSpecie
   character(10) :: nameOfOtherSpecie
   integer :: electronsID
   integer :: numberOfParticles
   integer :: numberOfOtherSpecieParticles
   integer :: ocupationNumber
   integer :: ocupationNumberOfOtherSpecie
   integer :: numberOfContractions
   integer :: numberOfContractionsOfOtherSpecie
   integer(8) :: numberOfOrbitals
   integer(8) :: numberOfSpatialOrbitals
   integer :: numberOfOtherSpecieOrbitals
   integer :: numberOfOtherSpecieSpatialOrbitals
   integer, allocatable :: spin(:)
   integer, allocatable :: spatialOrbital(:)
   type(Vector) :: eigenValues, ff
   type(Vector) :: eigenValuesOfOtherSpecie
   type(Matrix) :: auxMatrix!   type(TransformIntegrals) :: repulsionTransformer
   real(8) :: lambda
   real(8) :: lambdaOfOtherSpecie
   real(8) :: kappa !positive or negative exchange
   real(8) :: charge
   real(8) :: TwoParticlesEnergy, ECCSD, DECC, OLDCC, auxECCSD
   real(8) :: otherSpecieCharge
   real(8) :: independentEnergyCorrection
   real(8) :: couplingEnergyCorrection
   real(8) :: auxVal,auxVal1,auxVal2,value1,value2
   real(8) :: auxVal_A
   real(8) :: auxVal_B
   type(Matrix) :: eigenVec, Fs
   type(Matrix) :: eigenVecOtherSpecie
!   real(8), allocatable :: ff(:)
   real(8), allocatable :: Ts(:,:),Fae(:,:),Fmi(:,:),Fme(:,:),Dai(:,:),TsNew(:,:)
   real(8), allocatable :: Td(:,:,:,:), spinints(:,:,:,:), Dabij(:,:,:,:), taus(:,:,:,:), tau(:,:,:,:), Wmnij(:,:,:,:), Wabef(:,:,:,:), Wmbej(:,:,:,:), TdNew(:,:,:,:)
   type(Matrix), allocatable :: auxMatrix1(:,:)
   character(50) :: wfnFile
   character(50) :: arguments(2)
   integer :: wfnUnit


    wfnFile = "lowdin.wfn"
    wfnUnit = 20

    !! Open file for wavefunction
    open(unit=wfnUnit, file=trim(wfnFile), status="old", form="unformatted")

    !! Load results...
    call Vector_getFromFile(unit=wfnUnit, binary=.true., value=HartreeFock_instance%totalEnergy, &
         arguments=["TOTALENERGY"])
    call Vector_getFromFile(unit=wfnUnit, binary=.true., value=HartreeFock_instance%puntualInteractionEnergy, &
         arguments=["PUNTUALINTERACTIONENERGY"])


    numberOfSpecies = MolecularSystem_getNumberOfQuantumSpecies()

    do speciesID=1, numberOfSpecies
	lambda=MolecularSystem_getLambda(speciesID) !Particles per orbital
        kappa=MolecularSystem_getKappa(speciesID) !exchange sign
        charge=MolecularSystem_getCharge(speciesID)
    	ocupationNumber = MolecularSystem_getOcupationNumber(speciesID)
	numberOfContractions = MolecularSystem_getTotalNumberOfContractions( speciesID )
        numberOfOrbitals = numberOfContractions*lambda
        numberOfSpatialOrbitals = (numberOfOrbitals/lambda)*2 !Twice the dimension of spatial orbitals
!
         arguments(2) = MolecularSystem_getNameOfSpecie(speciesID)

    	!! Read transformed integrals from file
        call ReadTransformedIntegrals_readOneSpecies( speciesID, auxMatrix)

         arguments(1) = "ORBITALS"
         call Vector_getFromFile( elementsNum = numberOfContractions, &
              unit = wfnUnit, binary = .true., arguments = arguments(1:2), &
              output = eigenValues )

	call Matrix_diagonalConstructor (eigenVec, eigenValues) ! put MO energies in diagonal array (eigenVec) 
	call Vector_constructor (ff,numberOfContractions*2,0.0_8)
!	call Vector_show (ff)

	a=0
	b=0
	do x=1, numberOfContractions
		a=a+1
		do i=1, 2
			b=b+1
			ff%values(b) = eigenValues%values(a)
!			write(*,*) x,a,b,i,eigenValues%values(a)
		end do
	end do

	call Matrix_diagonalConstructor (Fs, ff)
!	call Matrix_show (Fs)
	
	numberOfParticles = MolecularSystem_getNumberOfParticles(speciesID)
	
	! Inital guess for T2, initial guess for the cluster amplitudes are the Moller-Plesset first-order perturbed wave function.
	! t_i^a=0 ; t_{ij}^{ab}= <ij||ab>/(E_i + E_j - E_a - E_b)

	call Vector_constructor( CoupledCluster_instance%energyCorrectionOfSecondOrder, numberOfSpecies)

	do a=1, ocupationNumber
		do b=1, ocupationNumber
			do i=ocupationNumber+1, numberOfContractions
				do j=i, numberOfContractions
					auxIndex = IndexMap_tensorR4ToVector(a,i,b,j, numberOfContractions)
					auxVal_A= auxMatrix%values(auxIndex, 1)

						if (  dabs( auxVal_A)  > 1.0E-10_8 ) then

                                                        if ( j>i ) then

                                                                if (a==b) then

                                                                        if( abs( lambda  -  1.0_8 ) > CONTROL_instance%DOUBLE_ZERO_THRESHOLD ) then

                                                                                independentEnergyCorrection = independentEnergyCorrection + 2.0_8 *  auxVal_A**2.0  &
                                                                                * ( lambda  -  1.0_8 ) / ( eigenValues%values(a) + eigenValues%values(b) &
                                                                                - eigenValues%values(i) - eigenValues%values(j) )

                                                                        end if

                                                                else

                                                                        auxIndex = IndexMap_tensorR4ToVector(i, b, j, a, numberOfContractions )
                                                                        auxVal_B= auxMatrix%values(auxIndex, 1)

                                                                        independentEnergyCorrection = independentEnergyCorrection + 2.0_8 *  auxVal_A  &
                                                                        * ( lambda * auxVal_A  - auxVal_B ) / ( eigenValues%values(a) + eigenValues%values(b) &
                                                                        - eigenValues%values(i) - eigenValues%values(j) )

                                                                end if

                                                        else if ( a==b .and. i==j ) then

                                                                if ( abs( lambda  -  1.0_8 ) > CONTROL_instance%DOUBLE_ZERO_THRESHOLD ) then

                                                                        independentEnergyCorrection = independentEnergyCorrection +  auxVal_A**2.0_8  &
                                                                                * ( lambda - 1.0_8 ) / ( 2.0_8*( eigenValues%values(a)-eigenValues%values(i)))

                                                                end if

                                                        else

                                                                if ( abs( lambda  -  1.0_8 ) > CONTROL_instance%DOUBLE_ZERO_THRESHOLD ) then
                                                                        independentEnergyCorrection = independentEnergyCorrection +  auxVal_A**2.0  &
                                                                                * ( lambda  - 1.0_8 ) / ( eigenValues%values(a) + eigenValues%values(b) &
                                                                                - eigenValues%values(i) - eigenValues%values(j) )
                                                                end if

                                                        end if
                                                end if


                                        end do
                                end do
                        end do

		end do

                CoupledCluster_instance%energyCorrectionOfSecondOrder%values(speciesID) = independentEnergyCorrection &
                        * ( ( MolecularSystem_getCharge( speciesID ) )**4.0_8 )

		!! Suma las correcciones de energia para especies independientes
		CoupledCluster_instance%secondOrderCorrection = sum( CoupledCluster_instance%energyCorrectionOfSecondOrder%values ) !MP2 Corr. Energy


!!! From scratch...
	
	numberOfContractions=numberOfContractions*2

        if (allocated(spinints)) deallocate (spinints)
        allocate(spinints(numberOfContractions,numberOfContractions,numberOfContractions,numberOfContractions))
        spinints(:,:,:,:) = 0.0_8
        
        do p=1, numberOfContractions
                do q=1, numberOfContractions
                        do r=1, numberOfContractions
                                do s=1, numberOfContractions
                                        value1 = IndexMap_tensorR4ToVector((p+1)/2,(r+1)/2,(q+1)/2,(s+1)/2,numberOfContractions/2)
                                        auxVal_A= auxMatrix%values(value1, 1)
                                        value2 = IndexMap_tensorR4ToVector((p+1)/2,(s+1)/2,(q+1)/2,(r+1)/2,numberOfContractions/2)
                                        auxVal_B= auxMatrix%values(value2, 1)
                                        auxVal1 = auxVal_A * (mod(p,2) == mod(r,2)) * (mod(q,2) == mod(s,2))
                                        auxVal2 = auxVal_B * (mod(p,2) == mod(s,2)) * (mod(q,2) == mod(r,2))
                                        spinints(p,q,r,s) = auxVal1 - auxVal2 !! p+1 o p-1? Revisar
                                end do
                        end do
                end do
        end do


!!!! Initial guesses T1 and T2

        if (allocated(Ts)) deallocate (Ts)
        allocate(Ts(numberOfContractions,numberOfContractions))
        Ts(:,:) = 0.0_8

        if (allocated(Td)) deallocate (Td)
        allocate(Td(numberOfContractions,numberOfContractions,numberOfContractions,numberOfContractions))
        Td(:,:,:,:) = 0.0_8

        if (allocated(taus)) deallocate (taus)
        allocate(taus(numberOfContractions,numberOfContractions,numberOfContractions,numberOfContractions))
        taus(:,:,:,:) = 0.0_8

        if (allocated(tau)) deallocate (tau)
        allocate(tau(numberOfContractions,numberOfContractions,numberOfContractions,numberOfContractions))
        tau(:,:,:,:) = 0.0_8

        do a=numberOfParticles+1, numberOfContractions
                do b=numberOfParticles+1, numberOfContractions
                        do i=1, numberOfParticles
                                do j=1, numberOfParticles
                                        Td(a,b,i,j) = Td(a,b,i,j) + (spinints(i,j,a,b)/(Fs%values(i,i)+Fs%values(j,j)-Fs%values(a,a)-Fs%values(b,b)))
                                        taus(a,b,i,j) = Td(a,b,i,j) + 0.5*(Ts(a,i)*Ts(b,j) - Ts(b,i)*Ts(a,j))
                                        tau(a,b,i,j) = Td(a,b,i,j) + Ts(a,i)*Ts(b,j) - Ts(b,i)*Ts(a,j)
!			                  write(*,*) a,b,i,j,Td(a,b,i,j)
                                end do
                        end do
                end do
        end do

!!!! End Initial Guesses

!!!! Make denominator arrays Dai, Dabij

        !! Equation 12 from Stanton

        if (allocated(Dai)) deallocate (Dai)
        allocate(Dai(numberOfContractions,numberOfContractions))
        Dai(:,:) = 0.0_8

        do a=numberOfParticles+1, numberOfSpatialOrbitals
                do i=1, numberOfParticles
                        Dai(a,i) = Fs%values(i,i) - Fs%values(a,a)
!			write(*,*) a,i,Dai(a,i)
                end do
        end do
        
        !! Equation 13 from Stanton

        if (allocated(Dabij)) deallocate (Dabij)
        allocate(Dabij(numberOfContractions,numberOfContractions,numberOfContractions,numberOfContractions))
        Dabij(:,:,:,:) = 0.0_8


        do a=numberOfParticles+1, numberOfContractions
                do b=numberOfParticles+1, numberOfContractions
                        do i=1, numberOfParticles
                                do j=1, numberOfParticles
                                        Dabij(a,b,i,j) = Fs%values(i,i)+Fs%values(j,j)-Fs%values(a,a)-Fs%values(b,b)
!					write(*,*) a,b,i,j,Dabij(a,b,i,j)
                                end do
                        end do
                end do
        end do

!!!! End Denominators

!!!! Main Loop

!  ECCSD = 0.0_8
!  DECC = 1.0_8 

!  do while (DECC >= 1.0D-9)
!	OLDCC = ECCSD

!do h=1, 50
!	OLDCC = ECCSD

	if (allocated(Fae)) deallocate (Fae)
        allocate(Fae(numberOfContractions,numberOfContractions))
	Fae=0.0_8
	if (allocated(Fmi)) deallocate (Fmi)
        allocate(Fmi(numberOfContractions,numberOfContractions))
	Fmi=0.0_8
	if (allocated(Fme)) deallocate (Fme)
        allocate(Fme(numberOfContractions,numberOfContractions))
	Fme=0.0_8

	if (allocated(Wmnij)) deallocate (Wmnij)
        allocate(Wmnij(numberOfContractions,numberOfContractions,numberOfContractions,numberOfContractions))
	Wmnij=0.0_8
	if (allocated(Wabef)) deallocate (Wabef)
        allocate(Wabef(numberOfContractions,numberOfContractions,numberOfContractions,numberOfContractions))
	Wabef=0.0_8
	if (allocated(Wmbej)) deallocate (Wmbej)
        allocate(Wmbej(numberOfContractions,numberOfContractions,numberOfContractions,numberOfContractions))
	Wmbej=0.0_8

	if (allocated(TsNew)) deallocate (TsNew)
	allocate(TsNew(numberOfContractions,numberOfContractions))
	TsNew=0.0_8
	if (allocated(TdNew)) deallocate (TdNew)
        allocate(TdNew(numberOfContractions,numberOfContractions,numberOfContractions,numberOfContractions))
	TdNew=0.0_8



!!!! Intermediates

	!! Equation 3

	do a=numberOfParticles+1, numberOfContractions-1
		do e=numberOfParticles+1, numberOfContractions-1
			Fae(a,e) = (1 - (a==e))*Fs%values(a,e)
			do m=1, numberOfParticles
				Fae(a,e) = Fae(a,e) + (-0.5*Fs%values(m,e)*Ts(a,m))
				do f=numberOfParticles+1, numberOfContractions-1
					Fae(a,e) = Fae(a,e) + Ts(f,m)*spinints(m,a,f,e)
					do n=1, numberOfParticles
						Fae(a,e) = Fae(a,e) + (-0.5*taus(a,f,m,n)*spinints(m,n,e,f))
!						write(*,*) a,e,Fae(a,e)
					end do
				end do
			end do
		end do
	end do

	!! Equation 4

	do m=1, numberOfParticles
		do i=1, numberOfParticles
			Fmi(m,i) = (1 - (m==i))*Fs%values(m,i)
			do e=numberOfParticles+1, numberOfContractions-1
				Fmi(m,i) = Fmi(m,i) + 0.5*Ts(e,i)*Fs%values(m,e)
				do n=1, numberOfParticles
					Fmi(m,i) = Fmi(m,i) + Ts(e,n)*spinints(m,n,i,e)
					do f=numberOfParticles+1, numberOfContractions-1
						Fmi(m,i) = Fmi(m,i) + 0.5*taus(e,f,i,n)*spinints(m,n,e,f)
					end do
				end do
			end do
		end do
	end do


	!! Equation 5

	do m=1, numberOfParticles
		do e=numberOfParticles+1, numberOfContractions-1
			Fme(m,e) = Fs%values(m,e)
			do n=1, numberOfParticles
				do f=numberOfParticles+1, numberOfContractions-1
				Fme(m,e) = Fme(m,e) + Ts(f,n)*spinints(m,n,e,f)
				end do
			end do
		end do
	end do

	!! Equation 6

	do m=1, numberOfParticles
		do n=1, numberOfParticles
			do i=1, numberOfParticles
				do j=1, numberOfParticles
					Wmnij(m,n,i,j) = spinints(m,n,i,j)
					do e=numberOfParticles+1, numberOfContractions-1
						Wmnij(m,n,i,j) = Wmnij(m,n,i,j) + (Ts(e,j)*spinints(m,n,i,e)-Ts(e,i)*spinints(m,n,j,e))
						do f=numberOfParticles+1, numberOfContractions-1
							Wmnij(m,n,i,j) = Wmnij(m,n,i,j) + 0.25*tau(e,f,i,j)*spinints(m,n,e,f)
						end do
					end do
				end do
			end do
		end do
	end do

	!! Equation 7

	do a=numberOfParticles+1, numberOfContractions-1
		do b=numberOfParticles+1, numberOfContractions-1
			do e=numberOfParticles+1, numberOfContractions-1
				do f=numberOfParticles+1, numberOfContractions-1
					Wabef(a,b,e,f) = spinints(a,b,e,f)
					do m=1, numberOfParticles
						Wabef(a,b,e,f) = Wabef(a,b,e,f) + (-Ts(b,m)*spinints(a,m,e,f)+Ts(a,m)*spinints(b,m,e,f))
						do n=1, numberOfParticles
							Wabef(a,b,e,f) = Wabef(a,b,e,f) + 0.25*tau(a,b,m,n)*spinints(m,n,e,f)
						end do
					end do
				end do
			end do
		end do
	end do

	!! Equation 8

	do m=1, numberOfParticles
		do b=numberOfParticles+1, numberOfContractions-1
			do e=numberOfParticles+1, numberOfContractions-1
				do j=1, numberOfParticles
					Wmbej(m,b,e,j) = spinints(m,b,e,j)
					do f=numberOfParticles+1, numberOfContractions-1
						Wmbej(m,b,e,j) = Wmbej(m,b,e,j) + Ts(f,j)*spinints(m,b,e,f)
					end do
					do n=1, numberOfParticles
						Wmbej(m,b,e,j) = Wmbej(m,b,e,j) + (-Ts(b,n)*spinints(m,n,e,f))
						do f=numberOfParticles+1, numberOfContractions-1
							Wmbej(m,b,e,j) = Wmbej(m,b,e,j) + (-0.5*Td(f,b,j,n)+Ts(f,j)*Ts(b,n))*spinints(m,n,e,f)
						end do
					end do
				end do
			end do
		end do
	end do

!!!! End Intermediates


auxECCSD = 0.0_8

	do i=1, numberOfParticles
		do a=numberOfParticles, numberOfContractions
			auxECCSD = auxECCSD + Fs%values(i,a)*Ts(a,i)
			do j=1, numberOfParticles
				do b=numberOfParticles, numberOfContractions
					auxECCSD = auxECCSD + (0.25*spinints(i,j,a,b)*Td(a,b,i,j)+0.5*spinints(i,j,a,b)*Ts(a,i)*Ts(b,j))
!					write(*,*) ECCSD
				end do
			end do
		end do
	end do
  ECCSD = auxECCSD
	
  DECC = abs( ECCSD - OLDCC )
 
!  write(*,*) ECCSD, OLDCC, DECC

!!!! Let's make T1 and T2 (the new ones) 

	!! Equation 1
do h=1, 10
	do a=numberOfParticles+1, numberOfContractions-1
		do i=1, numberOfParticles
			TsNew(a,i) = Fs%values(i,a)
			do e=numberOfParticles+1, numberOfContractions-1
				TsNew(a,i) = TsNew(a,i) + Ts(e,i)*Fae(a,e)
			end do
			do m=1, numberOfParticles
				TsNew(a,i) = TsNew(a,i) + (-Ts(a,m)*Fmi(m,i))
				do e=numberOfParticles+1, numberOfContractions-1
					TsNew(a,i) = TsNew(a,i) + Td(a,e,i,m)*Fme(m,e)
					do f=numberOfParticles+1, numberOfContractions-1
						TsNew(a,i) = TsNew(a,i) + (-0.5*Td(e,f,i,m)*spinints(m,a,e,f))
					end do
					do n=1, numberOfParticles
						TsNew(a,i) = TsNew(a,i) + (-0.5*Td(a,e,m,n)*spinints(n,m,e,i))
					end do
				end do
			end do
			do n=1,numberOfParticles
				do f=numberOfParticles+1, numberOfContractions-1
					TsNew(a,i) = TsNew(a,i) + (-Ts(f,n)*spinints(n,a,i,f))
				end do
			end do
			TsNew(a,i) = TsNew(a,i)/Dai(a,i)
!			Ts(a,i) = TsNew(a,i)
!			write(*,*) a,i,Ts(a,i),TsNew(a,i)
		end do
	end do
write (*,*) Ts(:,:)
write (*,*) "TSNEEEEEEEEEEEEEEEEEEEEEW"
write (*,*) TsNew(:,:)
			
end do
	!! Equation 2

	
	do a=numberOfParticles+1, numberOfContractions-1
		do b=numberOfParticles+1, numberOfContractions-1
			do i=1, numberOfParticles
				do j=1, numberOfParticles
					TdNew(a,b,i,j) = TdNew(a,b,i,j) + spinints(i,j,a,b)
					do e=numberOfParticles+1, numberOfContractions-1
						TdNew(a,b,i,j) = TdNew(a,b,i,j) + (Td(a,e,i,j)*Fae(b,e)-Td(b,e,i,j)*Fae(a,e))
						do m=1, numberOfParticles
							TdNew(a,b,i,j) = TdNew(a,b,i,j) + (-0.5*Td(a,e,i,j)*Ts(b,m)*Fme(m,e)+0.5*Td(a,e,i,j)*Ts(a,m)*Fme(m,e))
						end do
					end do
					do m=1, numberOfParticles
						TdNew(a,b,i,j) = TdNew(a,b,i,j) + (-Td(a,b,i,m)*Fmi(m,j)+Td(a,b,j,m)*Fmi(m,i))
						do e=numberOfParticles+1, numberOfContractions-1
							TdNew(a,b,i,j) = TdNew(a,b,i,j) + (-0.5*Td(a,b,i,m)*Ts(e,j)*Fme(m,e)+0.5*Td(a,b,i,m)*Ts(e,i)*Fme(m,e))
						end do
					end do
					do e=numberOfParticles+1, numberOfContractions-1
						TdNew(a,b,i,j) = TdNew(a,b,i,j) + (Ts(e,i)*spinints(a,b,e,j)-Ts(e,j)*spinints(a,b,e,i))
						do f=numberOfParticles+1, numberOfContractions-1
							TdNew(a,b,i,j) = TdNew(a,b,i,j) + 0.5*tau(e,f,i,j)*Wabef(a,b,e,f)
						end do
					end do
					do m=1, numberOfParticles
						TdNew(a,b,i,j) = TdNew(a,b,i,j) + (-Ts(a,m)*spinints(m,b,i,j)+Ts(b,m)*spinints(m,a,i,j))
						do e=numberOfParticles+1, numberOfContractions-1
							TdNew(a,b,i,j) = TdNew(a,b,i,j) + (Td(a,e,i,m)*Wmbej(m,b,e,j) - Ts(e,i)*Ts(a,m)*spinints(m,b,e,j))
							TdNew(a,b,i,j) = TdNew(a,b,i,j) - (Td(a,e,j,m)*Wmbej(m,b,e,i) + Ts(e,j)*Ts(a,m)*spinints(m,b,e,i))
							TdNew(a,b,i,j) = TdNew(a,b,i,j) - (Td(b,e,i,m)*Wmbej(m,a,e,j) - Ts(e,i)*Ts(b,m)*spinints(m,a,e,j))
							TdNew(a,b,i,j) = TdNew(a,b,i,j) + (Td(b,e,j,m)*Wmbej(m,a,e,i) - Ts(e,j)*Ts(b,m)*spinints(m,a,e,i))
						end do
						do n=1, numberOfParticles
							TdNew(a,b,i,j) = TdNew(a,b,i,j) + 0.5*tau(a,b,m,n)*Wmnij(m,n,i,j)
						end do
					end do
					TdNew(a,b,i,j) = TdNew(a,b,i,j)/Dabij(a,b,i,j)
!					Td(a,b,i,j) = TdNew(a,b,i,j)
!					write(*,*) TdNew(a,b,i,j)
				end do
			end do
		end do
	end do


!!!! End New T1 and T2


! end do !! Main Loop

	CoupledCluster_instance%coupledClusterSDCorrection = ECCSD !CCSD Corr. Energy

  end do !! Species

   close(wfnUnit)



 end subroutine CoupledCluster_iterateIntermediates
 

 
 !**
 ! @ Returns final energy (with CCSD correction)
 !**

! function CoupledCluster_getTotalEnergy() result(output)
!	implicit none
!	real(8) :: output
!
!	output = CoupledCluster_instance%totalEnergy
!
! end function CoupledCluster_getTotalEnergy

  !>
  !! @brief Muestra informacion del objeto
  !!
  !! @param this 
  !<
  subroutine CoupledCluster_getTransformedIntegrals()
    implicit none

!    type(TransformIntegrals) :: repulsionTransformer
    integer :: numberOfSpecies
    integer :: i,j,m,n,mu,nu
    integer :: specieID
    integer :: otherSpecieID
    character(10) :: nameOfSpecie
    character(10) :: nameOfOtherSpecie
    integer :: ocupationNumber
    integer :: ocupationNumberOfOtherSpecie
    integer :: numberOfContractions
    integer :: numberOfContractionsOfOtherSpecie
    type(Matrix) :: auxMatrix
    type(Matrix) :: molecularCouplingMatrix
    type(Matrix) :: molecularExtPotentialMatrix
    type(Matrix) :: couplingMatrix
    type(Matrix) :: hcoreMatrix
    type(Matrix) :: coefficients

    character(50) :: wfnFile
    character(50) :: arguments(20)
    integer :: wfnUnit

    numberOfSpecies = MolecularSystem_getNumberOfQuantumSpecies()
    allocate(CoupledCluster_instance%twoCenterIntegrals(numberOfSpecies))
    allocate(CoupledCluster_instance%fourCenterIntegrals(numberOfSpecies,numberOfSpecies))

!    print *,""
!    print *,"BEGIN INTEGRALS TRANFORMATION:"
!    print *,"========================================"
!    print *,""
!    print *,"--------------------------------------------------"
!    print *,"    Algorithm Four-index integral tranformation"
!    print *,"      Yamamoto, Shigeyoshi; Nagashima, Umpei. "
!    print *,"  Computer Physics Communications, 2005, 166, 58-65"
!    print *,"--------------------------------------------------"
!    print *,""
!
!    call TransformIntegrals_constructor( repulsionTransformer )

    do i=1, numberOfSpecies
        nameOfSpecie= trim(  MolecularSystem_getNameOfSpecie( i ) )
        specieID = MolecularSystem_getSpecieID( nameOfSpecie=nameOfSpecie )
        ocupationNumber = MolecularSystem_getOcupationNumber( i )
        numberOfContractions = MolecularSystem_getTotalNumberOfContractions( i )

!        write (6,"(T10,A)")"ONE PARTICLE INTEGRALS TRANSFORMATION FOR: "//trim(nameOfSpecie)
        call Matrix_constructor (CoupledCluster_instance%twoCenterIntegrals(i), int(numberOfContractions,8), int(numberOfContractions,8) )
        call Matrix_constructor (hcoreMatrix,int(numberOfContractions,8), int(numberOfContractions,8))
        call Matrix_constructor (couplingMatrix,int(numberOfContractions,8), int(numberOfContractions,8))

        hcoreMatrix  = HartreeFock_instance%HcoreMatrix 

!        hcoreMatrix%values = WaveFunction_HF_instance( specieID )%IndependentParticleMatrix%values

        !! Open file for wavefunction

        wfnFile = "lowdin.wfn"
        wfnUnit = 20

        open(unit=wfnUnit, file=trim(wfnFile), status="old", form="unformatted")

        arguments(2) = MolecularSystem_getNameOfSpecie(i)
        arguments(1) = "COEFFICIENTS"

        coefficients = &
          Matrix_getFromFile(unit=wfnUnit, rows= int(numberOfContractions,4), &
          columns= int(numberOfContractions,4), binary=.true., arguments=arguments(1:2))

        arguments(1) = "HCORE"

        hcoreMatrix = &
          Matrix_getFromFile(unit=wfnUnit, rows= int(numberOfContractions,4), &
          columns= int(numberOfContractions,4), binary=.true., arguments=arguments(1:2))

        do m=1,numberOfContractions
          do n=m, numberOfContractions
             do mu=1, numberOfContractions
                do nu=1, numberOfContractions
                    CoupledCluster_instance%twoCenterIntegrals(i)%values(m,n) = &
                        CoupledCluster_instance%twoCenterIntegrals(i)%values(m,n) + &
                        coefficients%values(mu,m)* &
                        coefficients%values(nu,n)* &
                        hcoreMatrix%values(mu,nu)
                end do
             end do
          end do
       end do

!! Not implemented yet
!!       if( WaveFunction_HF_instance( specieID )%isThereExternalPotential ) then
!!          do m=1,numberOfContractions
!!             do n=m, numberOfContractions
!!                do mu=1, numberOfContractions
!!                   do nu=1, numberOfContractions
!!                      CoupledCluster_instance%twoCenterIntegrals(i)%values(m,n) = &
!!                           CoupledCluster_instance%twoCenterIntegrals(i)%values(m,n) + &
!!                           WaveFunction_HF_instance( specieID )%waveFunctionCoefficients%values(mu,m)* &
!!                           WaveFunction_HF_instance( specieID )%waveFunctionCoefficients%values(nu,n) * &
!!                           WaveFunction_HF_instance( specieID )%ExternalPotentialMatrix%values(mu,nu)
!!                   end do
!!                end do
!!             end do
!!          end do
!!       end if

       do m=1,numberOfContractions
          do n=m, numberOfContractions
             CoupledCluster_instance%twoCenterIntegrals(i)%values(n,m)=&
                  CoupledCluster_instance%twoCenterIntegrals(i)%values(m,n)
          end do
       end do
          
       ! print *, "Independent Particle"
       ! call Matrix_show ( CoupledCluster_instance%twoCenterIntegrals(i) )

!       write (6,"(T10,A)")"TWO PARTICLES INTEGRALS TRANSFORMATION FOR: "//trim(nameOfSpecie)
!       print *,""

!       call TransformIntegrals_atomicToMolecularOfOneSpecie( repulsionTransformer, MolecularSystem_getEigenvectors(specieID), &
!            CoupledCluster_instance%fourCenterIntegrals(i,i), specieID, trim(nameOfSpecie) )

        call ReadTransformedIntegrals_readOneSpecies( specieID, CoupledCluster_instance%fourCenterIntegrals(i,i)   )

       if ( numberOfSpecies > 1 ) then
          do j = 1 , numberOfSpecies
             if ( i .ne. j) then
                nameOfOtherSpecie= trim(  MolecularSystem_getNameOfSpecie( j ) )
                otherSpecieID =MolecularSystem_getSpecieID( nameOfSpecie=nameOfOtherSpecie )
                ocupationNumberOfOtherSpecie = MolecularSystem_getOcupationNumber( j )
                numberOfContractionsOfOtherSpecie = MolecularSystem_getTotalNumberOfContractions( j )

!                write (6,"(T10,A)") "INTER-SPECIES INTEGRALS TRANSFORMATION FOR: "//trim(nameOfSpecie)//"/"//trim(nameOfOtherSpecie)
!                print *,""

!                call TransformIntegrals_atomicToMolecularOfTwoSpecies( repulsionTransformer, &
!                     MolecularSystem_getEigenVectors(i), MolecularSystem_getEigenVectors(j), &
!                     CoupledCluster_instance%fourCenterIntegrals(i,j), specieID, nameOfSpecie, otherSpecieID, nameOfOtherSpecie )

                 call ReadTransformedIntegrals_readTwoSpecies( specieID, otherSpecieID, &
                         CoupledCluster_instance%fourCenterIntegrals(i,j) )

             end if
          end do
       end if
    end do
!    print *,"END INTEGRALS TRANFORMATION:"
    close (wfnUnit)
	call Matrix_destructor (hcoreMatrix)
        call Matrix_destructor (couplingMatrix)

  end subroutine CoupledCluster_getTransformedIntegrals

  !>
  !! @brief  Maneja excepciones de la clase
  !<
  subroutine CoupledCluster_exception( typeMessage, description, debugDescription)
    implicit none
    integer :: typeMessage
    character(*) :: description
    character(*) :: debugDescription

    type(Exception) :: ex

    call Exception_constructor( ex , typeMessage )
    call Exception_setDebugDescription( ex, debugDescription )
    call Exception_setDescription( ex, description )
    call Exception_show( ex )
    call Exception_destructor( ex )

  end subroutine CoupledCluster_exception

end module CoupledCluster_
